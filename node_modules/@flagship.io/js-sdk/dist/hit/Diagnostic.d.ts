import { IFlagshipConfig } from '../config/index';
import { CacheStrategy, FSSdkStatus, LogLevel } from '../enum/index';
import { HitAbstract, IHitAbstract } from './HitAbstract';
import { BucketingDTO } from '../decision/api/bucketingDTO';
import { AccountSettings, EAIScore, FlagDTO, SerializedFlagMetadata, TroubleshootingLabel, primitive } from '../types';
import { CampaignDTO } from '../mod';
import { BatchTriggeredBy } from '../enum/BatchTriggeredBy';
export declare const ERROR_MESSAGE = "event category and event action are required";
export interface IDiagnostic extends IHitAbstract {
    version?: string;
    logLevel: LogLevel;
    accountId?: string;
    envId?: string;
    timestamp?: string;
    timeZone?: string;
    label: TroubleshootingLabel;
    lastInitializationTimestamp?: string;
    lastBucketingTimestamp?: string;
    stackType?: string;
    stackName?: string;
    stackVersion?: string;
    stackOriginName?: string;
    stackOriginVersion?: string;
    sdkStatus?: FSSdkStatus;
    sdkConfigMode?: string;
    sdkConfigLogLevel?: LogLevel;
    sdkConfigCustomLogManager?: boolean;
    sdkConfigCustomCacheManager?: boolean;
    sdkConfigStatusListener?: boolean;
    sdkConfigTimeout?: number;
    sdkConfigPollingInterval?: number;
    sdkConfigFetchNow?: boolean;
    sdkConfigReuseVisitorIds?: boolean;
    sdkConfigInitialBucketing?: BucketingDTO;
    sdkConfigDecisionApiUrl?: string;
    sdkConfigHitDeduplicationTime?: number;
    sdkConfigTrackingManagerStrategy?: CacheStrategy;
    sdkConfigTrackingManagerBatchIntervals?: number;
    sdkConfigTrackingManagerPoolMaxSize?: number;
    sdkBucketingFile?: BucketingDTO;
    sdkConfigUsingCustomHitCache?: boolean;
    sdkConfigUsingCustomVisitorCache?: boolean;
    sdkConfigUsingOnVisitorExposed?: boolean;
    sdkConfigFetchThirdPartyData?: boolean;
    sdkConfigFetchFlagsBufferingTime?: number;
    sdkConfigNextFetchConfig?: Record<string, unknown>;
    sdkConfigDisableDeveloperUsageTracking?: boolean;
    sdkConfigDisableCache?: boolean;
    httpRequestUrl?: string;
    httpRequestMethod?: string;
    httpRequestHeaders?: Record<string, unknown>;
    httpRequestBody?: unknown;
    httpResponseUrl?: string;
    httpResponseMethod?: string;
    httpResponseHeaders?: Record<string, unknown>;
    httpResponseCode?: number;
    httpResponseBody?: unknown;
    httpResponseTime?: number;
    visitorStatus?: string;
    visitorInstanceType?: string;
    visitorContext?: Record<string, primitive>;
    visitorConsent?: boolean;
    visitorAssignmentHistory?: Record<string, string>;
    visitorFlags?: Map<string, FlagDTO>;
    visitorCampaigns?: CampaignDTO[] | null;
    visitorCampaignFromCache?: CampaignDTO[] | null;
    visitorIsAuthenticated?: boolean;
    visitorInitialCampaigns?: CampaignDTO[];
    visitorInitialFlagsData?: SerializedFlagMetadata[];
    contextKey?: string;
    contextValue?: unknown;
    flagKey?: string;
    flagValue?: string;
    flagDefault?: unknown;
    visitorExposed?: boolean;
    flagMetadataCampaignId?: string;
    flagMetadataCampaignName?: string;
    flagMetadataVariationGroupId?: string;
    flagMetadataVariationGroupName?: string;
    flagMetadataVariationId?: string;
    flagMetadataVariationName?: string;
    flagMetadataCampaignSlug?: string | null;
    flagMetadataCampaignType?: string;
    flagMetadataCampaignIsReference?: boolean;
    hitContent?: Record<string, unknown>;
    batchTriggeredBy?: BatchTriggeredBy;
    visitorSessionId?: string;
    traffic?: number;
    flagshipInstanceId?: string;
    accountSettings?: AccountSettings;
    eAIScore?: EAIScore;
    isEAIScoreFromLocalCache?: boolean;
    eAIDataTimestamp?: string;
}
/**
 * Represents a diagnostic hit.
 */
export declare abstract class Diagnostic extends HitAbstract {
    data: Omit<IDiagnostic & {
        config: IFlagshipConfig;
    }, 'createdAt' | 'category'>;
    private _traffic?;
    get traffic(): number | undefined;
    set traffic(v: number | undefined);
    constructor(param: Omit<IDiagnostic & {
        config: IFlagshipConfig;
    }, 'createdAt' | 'category'>);
    /**
     * Gets the timezone of the user.
     * @returns The timezone as a string. If the timezone cannot be determined, it returns the offset from UTC in hours.
     */
    getTimezone(): string;
    toApiKeys(): any;
    isReady(checkParent?: boolean): boolean;
    getErrorMessage(): string;
}
