import * as __WEBPACK_EXTERNAL_MODULE_events__ from "events";
/******/ var __webpack_modules__ = ({

/***/ 121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisitorEvent: () => (/* binding */ VisitorEvent)
/* harmony export */ });
class VisitorEvent {
    _customerAccountId;
    _visitorId;
    _currentUrl;
    _clickPath;
    _clickPosition;
    _screenSize;
    _scrollPosition;
    get customerAccountId() {
        return this._customerAccountId;
    }
    get visitorId() {
        return this._visitorId;
    }
    get currentUrl() {
        return this._currentUrl;
    }
    get clickPath() {
        return this._clickPath;
    }
    get clickPosition() {
        return this._clickPosition;
    }
    get screenSize() {
        return this._screenSize;
    }
    get scrollPosition() {
        return this._scrollPosition;
    }
    constructor({ customerAccountId, visitorId, currentUrl, clickPath, clickPosition, screenSize, scrollPosition }) {
        this._customerAccountId = customerAccountId;
        this._visitorId = visitorId;
        this._currentUrl = currentUrl;
        this._clickPath = clickPath;
        this._clickPosition = clickPosition;
        this._screenSize = screenSize;
        this._scrollPosition = scrollPosition;
    }
    toApiKeys() {
        const apiKeys = {
            cid: this._customerAccountId,
            vid: this._visitorId,
            dl: this._currentUrl,
            sr: this._screenSize,
            t: 'VISITOREVENT'
        };
        if (this._clickPath) {
            apiKeys.cp = this._clickPath;
        }
        if (this._clickPosition) {
            apiKeys.cpo = this._clickPosition;
        }
        if (this._scrollPosition) {
            apiKeys.sp = this._scrollPosition;
        }
        return apiKeys;
    }
}


/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PageView: () => (/* binding */ PageView)
/* harmony export */ });
class PageView {
    _customerAccountId;
    _visitorId;
    _hasAdBlocker;
    _screenDepth;
    _screenSize;
    _doNotTrack;
    _fonts;
    _hasFakeBrowserInfos;
    _hasFakeLanguageInfos;
    _hasFakeOsInfos;
    _hasFakeResolutionInfos;
    _userLanguage;
    _deviceCategory;
    _pixelRatio;
    _plugins;
    _documentReferer;
    _viewportSize;
    _touchSupport;
    _currentUrl;
    _userAgent;
    _customerUserId;
    _timezoneOffset;
    _eventCategory;
    get customerAccountId() {
        return this._customerAccountId;
    }
    get visitorId() {
        return this._visitorId;
    }
    get hasAdBlocker() {
        return this._hasAdBlocker;
    }
    get screenDepth() {
        return this._screenDepth;
    }
    get screenSize() {
        return this._screenSize;
    }
    get doNotTrack() {
        return this._doNotTrack;
    }
    get fonts() {
        return this._fonts;
    }
    get hasFakeBrowserInfos() {
        return this._hasFakeBrowserInfos;
    }
    get hasFakeLanguageInfos() {
        return this._hasFakeLanguageInfos;
    }
    get hasFakeOsInfos() {
        return this._hasFakeOsInfos;
    }
    get hasFakeResolutionInfos() {
        return this._hasFakeResolutionInfos;
    }
    get userLanguage() {
        return this._userLanguage;
    }
    get deviceCategory() {
        return this._deviceCategory;
    }
    get pixelRatio() {
        return this._pixelRatio;
    }
    get plugins() {
        return this._plugins;
    }
    get documentReferer() {
        return this._documentReferer;
    }
    get viewportSize() {
        return this._viewportSize;
    }
    get touchSupport() {
        return this._touchSupport;
    }
    get currentUrl() {
        return this._currentUrl;
    }
    get userAgent() {
        return this._userAgent;
    }
    get customerUserId() {
        return this._customerUserId;
    }
    get timezoneOffset() {
        return this._timezoneOffset;
    }
    get eventCategory() {
        return this._eventCategory;
    }
    constructor({ customerAccountId, visitorId, hasAdBlocker, screenDepth, screenSize, doNotTrack, fonts, hasFakeBrowserInfos, hasFakeLanguageInfos, hasFakeOsInfos, hasFakeResolutionInfos, userLanguage, deviceCategory, pixelRatio, plugins, documentReferer, viewportSize, touchSupport, currentUrl, userAgent, customerUserId, timezoneOffset, eventCategory }) {
        this._customerAccountId = customerAccountId;
        this._visitorId = visitorId;
        this._hasAdBlocker = hasAdBlocker;
        this._screenDepth = screenDepth;
        this._screenSize = screenSize;
        this._doNotTrack = doNotTrack;
        this._fonts = fonts;
        this._hasFakeBrowserInfos = hasFakeBrowserInfos;
        this._hasFakeLanguageInfos = hasFakeLanguageInfos;
        this._hasFakeOsInfos = hasFakeOsInfos;
        this._hasFakeResolutionInfos = hasFakeResolutionInfos;
        this._userLanguage = userLanguage;
        this._deviceCategory = deviceCategory;
        this._pixelRatio = pixelRatio;
        this._plugins = plugins;
        this._documentReferer = documentReferer;
        this._viewportSize = viewportSize;
        this._touchSupport = touchSupport;
        this._currentUrl = currentUrl;
        this._userAgent = userAgent;
        this._customerUserId = customerUserId;
        this._timezoneOffset = timezoneOffset;
        this._eventCategory = eventCategory;
    }
    toApiKeys() {
        const apiKeys = {
            cid: this._customerAccountId,
            vid: this._visitorId,
            adb: this._hasAdBlocker,
            sd: this._screenDepth,
            sr: this._screenSize,
            dnt: this._doNotTrack,
            fnt: this._fonts,
            hlb: this._hasFakeBrowserInfos,
            hll: this._hasFakeLanguageInfos,
            hlo: this._hasFakeOsInfos,
            hlr: this._hasFakeResolutionInfos,
            ul: this._userLanguage,
            dc: this._deviceCategory,
            pxr: this._pixelRatio,
            dr: this._documentReferer,
            vp: this._viewportSize,
            tof: this._timezoneOffset,
            tsp: this._touchSupport,
            dl: this._currentUrl,
            ua: this._userAgent,
            ec: this._eventCategory,
            t: 'PAGEVIEW'
        };
        if (this._plugins) {
            apiKeys.plu = this._plugins;
        }
        if (this._customerUserId) {
            apiKeys.cuid = this._customerUserId;
        }
        return apiKeys;
    }
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ABTastyWebSDKPostMessageType: () => (/* reexport */ ABTastyWebSDKPostMessageType),
  APP_VERSION_CODE: () => (/* reexport */ APP_VERSION_CODE),
  APP_VERSION_NAME: () => (/* reexport */ APP_VERSION_NAME),
  CARRIER_NAME: () => (/* reexport */ CARRIER_NAME),
  CacheStrategy: () => (/* reexport */ CacheStrategy),
  DEVICE_LOCALE: () => (/* reexport */ DEVICE_LOCALE),
  DEVICE_MODEL: () => (/* reexport */ DEVICE_MODEL),
  DEVICE_TYPE: () => (/* reexport */ DEVICE_TYPE),
  DecisionApiConfig: () => (/* reexport */ DecisionApiConfig),
  DecisionMode: () => (/* reexport */ DecisionMode),
  EventCategory: () => (/* reexport */ EventCategory),
  FLAGSHIP_CLIENT: () => (/* reexport */ FLAGSHIP_CLIENT),
  FLAGSHIP_CONTEXT: () => (/* reexport */ FLAGSHIP_CONTEXT),
  FLAGSHIP_VERSION: () => (/* reexport */ FLAGSHIP_VERSION),
  FLAGSHIP_VISITOR: () => (/* reexport */ FLAGSHIP_VISITOR),
  FSFetchReasons: () => (/* reexport */ FSFetchReasons),
  FSFetchStatus: () => (/* reexport */ FSFetchStatus),
  FSFlag: () => (/* reexport */ FSFlag),
  FSFlagCollection: () => (/* reexport */ FSFlagCollection),
  FSFlagMetadata: () => (/* reexport */ FSFlagMetadata),
  FSFlagStatus: () => (/* reexport */ FSFlagStatus),
  FSSdkStatus: () => (/* reexport */ FSSdkStatus),
  Flagship: () => (/* reexport */ Flagship),
  HitType: () => (/* reexport */ HitType),
  INTERFACE_NAME: () => (/* reexport */ INTERFACE_NAME),
  INTERNET_CONNECTION: () => (/* reexport */ INTERNET_CONNECTION),
  IP: () => (/* reexport */ IP),
  LOCATION_CITY: () => (/* reexport */ LOCATION_CITY),
  LOCATION_COUNTRY: () => (/* reexport */ LOCATION_COUNTRY),
  LOCATION_LAT: () => (/* reexport */ LOCATION_LAT),
  LOCATION_LONG: () => (/* reexport */ LOCATION_LONG),
  LOCATION_REGION: () => (/* reexport */ LOCATION_REGION),
  LogLevel: () => (/* reexport */ LogLevel),
  OS_NAME: () => (/* reexport */ OS_NAME),
  OS_VERSION_CODE: () => (/* reexport */ OS_VERSION_CODE),
  OS_VERSION_NAME: () => (/* reexport */ OS_VERSION_NAME),
  TroubleshootingLabel: () => (/* reexport */ TroubleshootingLabel),
  Visitor: () => (/* reexport */ Visitor),
  VisitorCacheStatus: () => (/* reexport */ VisitorCacheStatus),
  "default": () => (/* binding */ src)
});

;// external "events"
var x = (y) => {
	var x = {}; __webpack_require__.d(x, y); return x
} 
var y = (x) => (() => (x))
const external_events_namespaceObject = x({ ["EventEmitter"]: () => (__WEBPACK_EXTERNAL_MODULE_events__.EventEmitter) });
;// ./src/sdkVersion.ts
// Generated by genversion.
const sdkVersion_version = '5.1.6';

;// ./src/enum/FlagshipConstant.ts

/**
 * SDK language
 */
const SDK_INFO = {
    name: 'TypeScript',
    version: sdkVersion_version
};
/**
 * Default request timeout in second
 */
const REQUEST_TIME_OUT = 2;
const FETCH_FLAG_BUFFERING_DEFAULT_TIME = 2;
const DEFAULT_DEDUPLICATION_TIME = 2.5;
const DEFAULT_POLLING_INTERVAL = 5;
const DEFAULT_SERVER_TIME_INTERVAL = 10;
const DEFAULT_SERVER_POOL_MAX_SIZE = 100;
const DEFAULT_BROWSER_TIME_INTERVAL = 5;
const DEFAULT_BROWSER_POOL_MAX_SIZE = 10;
const BATCH_MAX_SIZE = 2500000;
const ANALYTIC_HIT_ALLOCATION = 1;
const MAX_COLLECTING_TIME_MS = 30000;
const MAX_LAST_COLLECTING_TIME_MS = 120000;
const MAX_CLICK_PATH_LENGTH = 1900;
const MAX_SCORING_POLLING_TIME = 120000;
const SCROLL_END_DELAY_MS = 200;
const CLICK_PATH_DELAY_MS = 500;
const SCORING_INTERVAL = 5000;
/**
 * Decision api base url
 */
const BASE_API_URL = 'https://decision.flagship.io/v2/';
const HIT_API_URL = 'https://ariane.abtasty.com';
const HIT_EVENT_URL = 'https://events.flagship.io';
const TROUBLESHOOTING_HIT_URL = 'https://events.flagship.io/troubleshooting';
const USAGE_HIT_URL = 'https://events.flagship.io/analytics';
const BUCKETING_API_URL = 'https://cdn.flagship.io/{0}/bucketing.json';
const BUCKETING_API_CONTEXT_URL = 'https://decision.flagship.io/v2/{0}/events';
const THIRD_PARTY_SEGMENT_URL = 'https://api-data-connector.flagship.io/accounts/{0}/segments/{1}';
const HIT_CONSENT_URL = 'https://ariane.abtasty.com';
const URL_CAMPAIGNS = '/campaigns';
const URL_ACTIVATE_MODIFICATION = 'activate';
const QA_ASSISTANT_PROD_URL = 'https://qa-assistant.flagship.io/bundle.js';
const QA_ASSISTANT_STAGING_URL = 'https://staging-qa-assistant.flagship.io/bundle.js';
const QA_ASSISTANT_LOCAL_URL = 'https://local-qa-assistant.flagship.io:5000/bundle.js';
const FS_QA_ASSISTANT = 'fs_qa_assistant';
const FS_QA_ASSISTANT_STAGING = 'fs_qa_assistant_staging';
const FS_QA_ASSISTANT_LOCAL = 'fs_qa_assistant_local';
const TAG_QA_ASSISTANT = 'abtasty_qa_assistant';
const TAG_QA_ASSISTANT_STAGING = 'abtasty_qa_assistant_staging';
const TAG_QA_ASSISTANT_LOCAL = 'abtasty_qa_assistant_local';
const TAG_QA_URL = 'qa-assistant.abtasty.com';
const FS_QA_URL = 'qa-assistant.flagship.io';
const EXPOSE_ALL_KEYS = 'exposeAllKeys';
const SEND_CONTEXT_EVENT = 'sendContextEvent';
const FS_CONSENT = 'fs_consent';
const FS_IS_QA_MODE_ENABLED = 'FS_IS_QA_MODE_ENABLED';
const FS_FORCED_VARIATIONS = 'FS_FORCED_VARIATIONS';
const FS_QA_ASSISTANT_SCRIPT_TAG_ID = 'FS_QA_ASSISTANT_SCRIPT_TAG_ID';
const EMOTION_AI_UC_URL = 'https://uc-info.flagship.io/v1/segments/clients/{0}/visitors/{1}';
const CDN_ACCOUNT_SETTINGS_URL = 'https://cdn.flagship.io/{0}/accountSettings.json';
const VISITOR_EAI_SCORE_KEY = '{0}_EAIScore';
const EMOTION_AI_EVENT_URL = 'https://events.flagship.io/emotionsai';
const SEND_EAI_EVENT = 'sendEAIEvent';
const SEND_EAI_EVENT_ERROR = 'Failed to send Emotion AI event: {0}';
const SEND_EAI_EVENT_SUCCESS = 'Emotion AI event sent: {0}';
const FETCH_EAI_SCORE = 'fetchEAIScore';
const FETCH_EAI_SCORE_ERROR = 'visitor {0}, Failed to fetch EAIScore: {1}';
const FETCH_EAI_SCORE_SUCCESS = 'visitor {0}, EAIScore fetched: {1}';
const EAI_SCORE_CONTEXT_KEY = 'eai::eas';
const CLIENT_CACHE_KEY = 'FS_CLIENT_VISITOR';
/**
 * SDK version
 */
const SDK_VERSION = (/* unused pure expression or super */ null && (version));
const VISITOR_CACHE_VERSION = 1;
const HIT_CACHE_VERSION = 1;
const DEFAULT_HIT_CACHE_TIME_MS = 14400000;
const MAX_ACTIVATE_HIT_PER_BATCH = 100;
/**
 * Message Info
 */
const SDK_STARTED_INFO = 'Flagship SDK (version: {0}) {1} in **{2}** mode';
const FLAGSHIP_SDK = 'Flagship SDK';
const EMIT_READY = 'ready';
const EMIT_STATUS = 'status';
const NO_BATCHING_WITH_CONTINUOUS_CACHING_STRATEGY = 3;
const JS_DOC_URL = 'https://docs.developers.flagship.io/docs/js-v3';
const PANIC_MODE_DOC_URL = 'https://docs.developers.flagship.io/docs/glossary#panic-mode';
/**
 * Message Error
 */
const INITIALIZATION_PARAM_ERROR = `Params 'envId' and 'apiKey' must not be null or empty.
  Learn more: ${JS_DOC_URL}#initialization`;
const ERROR = 'error';
const CONTEXT_NULL_ERROR = 'Context must not to be null';
const CONTEXT_PARAM_ERROR = "params {0} must be a non null String, and 'value' must be one of the following types , Number, Boolean";
const GET_MODIFICATION_CAST_ERROR = 'Modification for key {0} has a different type. Default value is returned.';
const GET_MODIFICATION_MISSING_ERROR = 'No modification for key {0}. Default value is returned.';
const GET_MODIFICATION_KEY_ERROR = 'Key {0} must not be null. Default value is returned.';
const ACTIVATE_MODIFICATION_KEY_ERROR = 'Key {0} must not be null, no activate will be sent.';
const GET_MODIFICATION_ERROR = 'No modification for key {0}.';
const GET_FLAG_ERROR = 'No flag for key {0}.';
const ACTIVATE_MODIFICATION_ERROR = 'No modification for key {0}, no activate will be sent.';
const DECISION_MANAGER_MISSING_ERROR = 'decisionManager must not be null.';
const TRACKER_MANAGER_MISSING_ERROR = 'trackerManager must not be null.';
const CURL_LIBRARY_IS_NOT_LOADED = 'curl library is not loaded';
const TYPE_ERROR = '{0} must be a {1}';
const TYPE_INTEGER_ERROR = 'value of {0} is not an {1}, it will be truncated to {1}';
const VISITOR_ID_ERROR = 'visitorId must not be null or empty';
const PANIC_MODE_ERROR = '{0} deactivated while panic mode is on.';
const METHOD_DEACTIVATED_CONSENT_ERROR = 'Method {0} is deactivated for visitor {1} : visitor did not consent.';
const METHOD_DEACTIVATED_ERROR = 'Visitor {0}, method {1} is deactivated while SDK status is: {2}.';
const METHOD_DEACTIVATED_SEND_CONSENT_ERROR = 'Send consent hit is deactivated while SDK status is: {1}.';
const TROUBLESHOOTING_HIT_ADDED_IN_QUEUE = 'The TROUBLESHOOTING HIT has been added to the pool queue : {0}';
const ANALYTICS_HIT_ADDED_IN_QUEUE = 'The USAGE HIT has been added to the pool queue : {0}';
const ACTIVATE_ADDED_IN_QUEUE = 'The ACTIVATE has been added to the pool queue : {0}';
const HIT_ADDED_IN_QUEUE = 'The HIT has been added into the pool queue : {0}';
const ADD_HIT = 'ADD HIT';
const ADD_TROUBLESHOOTING_HIT = 'ADD TROUBLESHOOTING HIT';
const ADD_USAGE_HIT = 'ADD USAGE HIT';
const ADD_ACTIVATE = 'ADD ACTIVATE';
const BATCH_SENT_SUCCESS = 'Batch hit has been sent : {0}';
const TROUBLESHOOTING_SENT_SUCCESS = 'Troubleshooting hit has been sent : {0}';
const ANALYTICS_HIT_SENT_SUCCESS = 'Usage hit has been sent : {0}';
const ACTIVATE_SENT_SUCCESS = 'Activate hit has been sent : {0}';
const SEND_BATCH = 'SEND BATCH';
const SEND_TROUBLESHOOTING = 'SEND TROUBLESHOOTING';
const SEND_USAGE_HIT = 'SEND USAGE HIT';
const SEND_ACTIVATE = 'SEND ACTIVATE';
const SEND_SEGMENT_HIT = 'SEND SEGMENT HIT';
const SEND_HIT = 'SEND HIT';
const EVENT_SUFFIX = 'events';
const FETCH_FLAGS_BUFFERING_MESSAGE = 'Visitor {0}, fetchFlags has been ignored and will continue to be ignored for the next {1}ms, this delay can be changed with `fetchFlagsBufferingTime` option in the SDK config';
const VISITOR_SYNC_FLAGS_MESSAGE = 'without calling `fetchFlags` method afterwards. So, the value of the flag `{1}` might be outdated';
const NEW_VISITOR_NOT_READY = `You can't create a new visitor without first calling the "Flagship.start" method.
Learn more: ${JS_DOC_URL}#initialization
`;
const LOOKUP_HITS_JSON_OBJECT_ERROR = 'JSON DATA must fit the type HitCacheDTO';
const ACTIVATE_BATCH_LENGTH = 5;
// Process
const PROCESS = 'process';
const PROCESS_INITIALIZATION = 'INITIALIZATION';
const PROCESS_UPDATE_CONTEXT = 'UPDATE CONTEXT';
const PROCESS_GET_MODIFICATION = 'GET MODIFICATION';
const PROCESS_GET_MODIFICATION_INFO = 'GET MODIFICATION INFO';
const PROCESS_NEW_VISITOR = 'NEW VISITOR';
const PROCESS_ACTIVE_MODIFICATION = 'ACTIVE MODIFICATION';
const PROCESS_SYNCHRONIZED_MODIFICATION = 'SYNCHRONIZED MODIFICATION';
const PROCESS_SEND_HIT = 'ADD HIT';
const PROCESS_SEND_ACTIVATE = 'SEND ACTIVATE';
const PROCESS_GET_CAMPAIGNS = 'GET CAMPAIGNS';
const PROCESS_GET_ALL_MODIFICATION = 'GET ALL MODIFICATIONS';
const PROCESS_MODIFICATIONS_FOR_CAMPAIGN = 'GET MODIFICATION FOR CAMPAIGN';
const PROCESS_CACHE_HIT = 'CACHE HIT';
const PROCESS_FLUSH_HIT = 'FLUSH HIT';
const PROCESS_LOOKUP_HIT = 'LOOKUP HIT';
// Api items
const BATCH = 'batch';
const CUSTOMER_ENV_ID_API_ITEM = 'cid';
const CUSTOMER_ENV_ID_API_ACTIVATE = 'cid';
const CUSTOMER_UID = 'cuid';
const ANONYMOUS_ID = 'aid';
const VISITOR_ID_API_ITEM = 'vid';
const VARIATION_GROUP_ID_API_ITEM = 'caid';
const VARIATION_GROUP_ID_API_ITEM_ACTIVATE = 'caid';
const VISITOR_CONSENT = 'vc';
const CAMPAIGN_ID = 'caid';
const VARIATION_ID_API_ITEM = 'vaid';
const DS_API_ITEM = 'ds';
const T_API_ITEM = 't';
const QT_API_ITEM = 'qt';
const QA_MODE_API_ITEM = 'qa';
const DL_API_ITEM = 'dl';
const SL_ITEM = 'sl';
const SDK_APP = 'APP';
const TID_API_ITEM = 'tid';
const TA_API_ITEM = 'ta';
const TT_API_ITEM = 'tt';
const TC_API_ITEM = 'tc';
const TCC_API_ITEM = 'tcc';
const ICN_API_ITEM = 'icn';
const SM_API_ITEM = 'sm';
const PM_API_ITEM = 'pm';
const TR_API_ITEM = 'tr';
const TS_API_ITEM = 'ts';
const IN_API_ITEM = 'in';
const IC_API_ITEM = 'ic';
const IP_API_ITEM = 'ip';
const IQ_API_ITEM = 'iq';
const IV_API_ITEM = 'iv';
const S_API_ITEM = 's';
const EVENT_CATEGORY_API_ITEM = 'ec';
const EVENT_ACTION_API_ITEM = 'ea';
const EVENT_LABEL_API_ITEM = 'el';
const EVENT_VALUE_API_ITEM = 'ev';
const USER_IP_API_ITEM = 'uip';
const SCREEN_RESOLUTION_API_ITEM = 'sr';
const USER_LANGUAGE = 'ul';
const SESSION_NUMBER = 'sn';
const HEADER_X_API_KEY = 'x-api-key';
const HEADER_X_ENV_ID = 'x-env-id';
const HEADER_CONTENT_TYPE = 'Content-Type';
const HEADER_X_SDK_CLIENT = 'x-sdk-client';
const HEADER_X_SDK_VERSION = 'x-sdk-version';
const HEADER_APPLICATION_JSON = 'application/json';
// Log
const INITIALIZATION_STARTING = 'Flagship SDK version {0} is starting in {1} mode with config {2}';
const BUCKETING_POOLING_STARTED = 'Bucketing polling process has been started';
const BUCKETING_POOLING_STOPPED = 'Bucketing polling process has been stopped';
const PROCESS_BUCKETING = 'BUCKETING';
const POLLING_EVENT_200 = 'Polling event with code status 200 : {0}';
const POLLING_EVENT_300 = 'Polling event with code status 304';
const POLLING_EVENT_FAILED = 'Polling event failed with error';
const PROCESS_SDK_STATUS = 'SDK STATUS';
const SDK_STATUS_CHANGED = 'SDK status has changed:  {0}';
const SAVE_VISITOR_INSTANCE = 'Visitor {0} has been saved in SDK instance';
const VISITOR_CREATED = 'Visitor {0} has been created with context {1}, isAuthenticated:{2} and hasConsented {3}';
const VISITOR_PROFILE_LOADED = 'Visitor profile has been loaded {0}';
const VISITOR_ID_FROM_AB_TASTY_TAG = "The visitor ID '{0}' has been retrieved from ABTasty tag";
const VISITOR_ID_GENERATED = 'Visitor identifier is empty. A UUID {0} has been generated.';
const PREDEFINED_CONTEXT_LOADED = 'Predefined Context have been loaded {0}';
const CONTEXT_KEY_ERROR = `Visitor {0}, the key '{1}' must be a non null String.
Learn more: ${JS_DOC_URL}#updating-the-visitor-context`;
const CONTEXT_VALUE_ERROR = `Visitor {0}, 'value' for key '{1}[], must be one of the following types : String, Number, Boolean
Learn more: ${JS_DOC_URL}#updating-the-visitor-context`;
const PREDEFINED_CONTEXT_TYPE_ERROR = `visitor {0}, Predefined Context {0} must be of type {1}
Learn more: ${JS_DOC_URL}#predefined-user-context-keys-`;
const CONTEXT_KEY_VALUE_UPDATE = 'visitor `{0}`, context have been updated: key {1}, value {2}, Context {3}';
const CONTEXT_OBJET_PARAM_UPDATE = 'visitor `{0}`, context have been updated: key/value {1}, Context {2}';
const CLEAR_CONTEXT = 'visitor `{0}`, context has been cleared cleared `{1}`';
const PROCESS_CLEAR_CONTEXT = 'CLEAR_CONTEXT';
const CONSENT_CHANGED = 'Visitor `{0}` consent has been changed : {1}';
const PROCESS_SET_CONSENT = 'SET_CONSENT';
const FETCH_CAMPAIGNS_SUCCESS = 'Visitor {0}, anonymousId {1} with context {2} has just fetched campaigns {3} in {4} ms';
const FETCH_CAMPAIGNS_FROM_CACHE = 'Visitor {0}, anonymousId {1} with context {2} has just fetched campaigns from cache {3} in {4} ms';
const FETCH_FLAGS_FROM_CAMPAIGNS = 'Visitor {0}, anonymousId {1} with context {2} has just fetched flags {3} from Campaigns';
const FETCH_FLAGS_STARTED = 'visitor `{0}` fetchFlags process is started';
const FETCH_FLAGS_PANIC_MODE = 'Panic mode is enabled : all feature are disabled except fetchFlags.';
const PROCESS_FETCHING_FLAGS = 'FETCH_FLAGS';
const GET_FLAG_MISSING_ERROR = 'For the visitor "{0}", no flags were found with the key "{1}". Therefore, the default value "{2}" has been returned.';
const GET_FLAG_NOT_FOUND = 'For the visitor "{0}", no flags were found with the key "{1}". Therefore, an empty flag has been returned.';
const FETCH_FLAGS_MISSING = 'Visitor {0} has {1} without calling fetchFlags method, ';
const FLAG_VALUE = 'FLAG_VALUE';
const GET_FLAG = 'GET_FLAG';
const GET_FLAG_CAST_ERROR = 'For the visitor "{0}", the flag with key "{1}" has a different type compared to the default value. Therefore, the default value "{2}" has been returned.';
const GET_FLAG_VALUE = 'Visitor {0}, Flag for key {1} returns value {2}';
const USER_EXPOSED_FLAG_ERROR = 'For the visitor "{0}", no flags were found with the key "{1}". As a result, user exposure will not be sent.';
const VISITOR_EXPOSED_VALUE_NOT_CALLED = 'For the visitor `{0}`,assuming the getValue() method has not previously been invoked for the flag `{0}`. Therefore, the exposure is canceled';
const FLAG_VISITOR_EXPOSED = 'FLAG_VISITOR_EXPOSED';
const USER_EXPOSED_CAST_ERROR = 'For the visitor `{0}, the flag with the key `{0}` has a different type compared to the default value. Therefore, the exposure is interrupted';
const GET_METADATA_CAST_ERROR = 'Visitor {0}, Flag for key {1} has a different type with default value: Empty metadata object is returned {2}';
const FLAG_METADATA = 'FLAG_METADATA';
const NO_FLAG_METADATA = 'Visitor {0}, No Flags found for key {1}:  Empty metadata object is returned';
const METADATA_SDK_NOT_READY = `Visitor {0}, Flag for key {1} Method Flag.metadata is deactivated while SDK status is NOT_READY: Empty metadata object is returned {2}
Learn more: ${JS_DOC_URL}#getting-flags-campaigns-metadata`;
const METADATA_PANIC_MODE = `Visitor {0}, Flag for key {1} Method Flag.metadata is deactivated while SDK status is PANIC: Empty metadata object is returned {2}
Learn more: ${PANIC_MODE_DOC_URL}`;
const AUTHENTICATE = 'AUTHENTICATE';
const VISITOR_AUTHENTICATE = 'The visitor is authenticated with new visitor ID {0} anonymous ID {1}';
const VISITOR_ALREADY_AUTHENTICATE = 'The visitor is already authenticated with visitor ID {0}';
const METHOD_DEACTIVATED_BUCKETING_ERROR = 'Visitor {0}, Method {1} is deactivated on Bucketing mode';
const VISITOR_AUTHENTICATE_VISITOR_ID_ERROR = `Visitor {0}, visitorId must not be null or empty
Learn more: ${JS_DOC_URL}#authenticate`;
const VISITOR_UNAUTHENTICATE = 'The visitor is unauthenticated with visitor ID {0}';
const UNAUTHENTICATE = 'UNAUTHENTICATE';
const FLAGSHIP_VISITOR_NOT_AUTHENTICATE = 'Visitor {0} is not authenticated yet';
const ALLOCATION = 'ALLOCATION';
const BUCKETING_VARIATION_CACHE = 'Visitor {0}, Variation {1} selected from cache.';
const BUCKETING_NEW_ALLOCATION = 'Visitor {0}, Variation {1} selected with allocation {2}.';
const LOOKUP_VISITOR_JSON_OBJECT_ERROR = `lookupVisitor method has loaded a bad format version ({0}) for visitor {1}.
Learn more: ${JS_DOC_URL}#managing-visitor-cache`;
const PROCESS_CACHE = 'CACHE';
const VISITOR_CACHE_ERROR = 'visitor {0}. {1} threw an exception {2}';
const HIT_CACHE_ERROR = '{0} threw an exception {1}';
const VISITOR_CACHE_LOADED = 'Visitor {0}, visitor cache has been loaded from database: {1}';
const VISITOR_CACHE_SAVED = 'Visitor {0}, visitor cache has been saved into database : {0}';
const VISITOR_CACHE_FLUSHED = 'Visitor {0}, visitor cache has been flushed from database.';
const HIT_CACHE_LOADED = 'Hits cache has been loaded from database: {0}';
const HIT_CACHE_SAVED = 'Hit cache has been saved into database : {0}';
const HIT_DATA_FLUSHED = 'The following hit keys have been flushed from database : {0}';
const ALL_HITS_FLUSHED = 'All hits cache has been flushed from database';
const BATCH_LOOP_STARTED = 'The Batch Loop has been started with a time interval of {0} ms';
const TRACKING_MANAGER = 'TRACKING_MANAGER';
const BATCH_LOOP_STOPPED = 'The Batch Loop has been stopped';
const TRACKING_MANAGER_ERROR = '{0} Unexpected Error occurred {1}';
const HIT_SENT_SUCCESS = '{0} has been sent : {1}';
const ACTIVATE_HIT = 'ACTIVATE HIT';
const BATCH_HIT = 'BATCH HIT';
const DIRECT_HIT = 'HIT';
const GET_THIRD_PARTY_SEGMENT = 'GET_THIRD_PARTY_SEGMENT';
const CONSENT_NOT_SPECIFY_WARNING = 'Consent has not been specified. By default, consent is set to false, which may result in some features being deactivated.';
const ACTION_TRACKING = 'Action Tracking';
const ACTION_TRACKING_HIT_RECEIVED = 'Hit received: {0}';
const ACTION_TRACKING_INVALID_HIT = 'Invalid hit data: {0}';
const ACTION_TRACKING_INVALID_NONCE = 'Invalid nonce: {0}';
const ACTION_TRACKING_SENDING_HIT = 'Sending hit: {0}';
const ACTION_TRACKING_SENDING_HIT_ERROR = 'Failed to send hit: {0}';
const ACTION_TRACKING_DISPATCHED = 'action tracking hits have been dispatched {0}';
const TRUSTED_QA_ORIGINS = (/* unused pure expression or super */ null && ([
    'https://local-qa-assistant.abtasty.com:5000',
    'https://staging-qa-assistant.abtasty.com',
    'https://qa-assistant.abtasty.com',
    'https://qa-assistant.flagship.io',
    'https://local-qa-assistant.flagship.io:5000',
    'https://staging-qa-assistant.flagship.io'
]));

;// ./src/visitor/Visitor.ts


/**
 * The `Visitor` class represents a unique user within your application. It aids in
 * managing the visitor's data and fetching the corresponding flags for the visitor
 * from the [Flagship platform](https://app.flagship.io/login) .
 */
class Visitor extends external_events_namespaceObject.EventEmitter {
    visitorDelegate;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _onReady;
    constructor(visitorDelegate) {
        super();
        this.visitorDelegate = visitorDelegate;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._onReady = (err) => {
            this.emit(EMIT_READY, err);
        };
        this.visitorDelegate.on(EMIT_READY, this._onReady);
        const instance = this;
        instance.sendEaiVisitorEvent = (event) => {
            this.visitorDelegate.sendEaiVisitorEvent(event);
        };
        instance.sendEaiPageView = (pageView) => {
            this.visitorDelegate.sendEaiPageView(pageView);
        };
        instance.onEAICollectStatusChange = (callback) => {
            this.visitorDelegate.onEAICollectStatusChange(callback);
        };
    }
    /**
     * @inheritdoc
     */
    get visitorId() {
        return this.visitorDelegate.visitorId;
    }
    /**
     * @inheritdoc
     */
    set visitorId(v) {
        this.visitorDelegate.visitorId = v;
    }
    /**
     * @inheritdoc
     */
    get anonymousId() {
        return this.visitorDelegate.anonymousId;
    }
    /**
     * @inheritdoc
     */
    get config() {
        return this.visitorDelegate.config;
    }
    /**
     * @inheritdoc
     */
    get context() {
        return this.visitorDelegate.context;
    }
    /**
     * @inheritdoc
     */
    get flagsStatus() {
        return this.visitorDelegate.flagsStatus;
    }
    /**
     * @inheritdoc
     */
    get hasConsented() {
        return this.visitorDelegate.hasConsented;
    }
    /**
     * @inheritdoc
     */
    setConsent(hasConsented) {
        this.visitorDelegate.setConsent(hasConsented);
    }
    updateContext(context, value) {
        this.visitorDelegate.updateContext(context, value);
    }
    /**
     * @inheritdoc
     */
    clearContext() {
        this.visitorDelegate.clearContext();
    }
    /**
     * @inheritdoc
     */
    getFlag(key) {
        return this.visitorDelegate.getFlag(key);
    }
    /**
     * @inheritdoc
     */
    getFlags() {
        return this.visitorDelegate.getFlags();
    }
    /**
     * @inheritdoc
     */
    fetchFlags() {
        return this.visitorDelegate.fetchFlags();
    }
    sendHit(hit) {
        return this.visitorDelegate.sendHit(hit);
    }
    sendHits(hits) {
        return this.visitorDelegate.sendHits(hits);
    }
    /**
     * @inheritdoc
     */
    authenticate(visitorId) {
        this.visitorDelegate.authenticate(visitorId);
    }
    /**
     * @inheritdoc
     */
    unauthenticate() {
        this.visitorDelegate.unauthenticate();
    }
    /**
     * @inheritdoc
     */
    collectEAIEventsAsync(...args) {
        let currentPage;
        if (args.length > 0) {
            currentPage = args[0];
        }
        return this.visitorDelegate.collectEAIEventsAsync(currentPage);
    }
    /**
     * @inheritdoc
     */
    cleanup() {
        this.visitorDelegate.cleanup();
        this.visitorDelegate.off(EMIT_READY, this._onReady);
    }
}

;// ./src/enum/FSSdkStatus.ts
/**
 * Enum representing the status of the Flagship SDK.
 */
var FSSdkStatus;
(function (FSSdkStatus) {
    /**
     * It is the default initial status. This status remains until the sdk has been initialized successfully.
     */
    FSSdkStatus[FSSdkStatus["SDK_NOT_INITIALIZED"] = 0] = "SDK_NOT_INITIALIZED";
    /**
     * The SDK is currently initializing.
     */
    FSSdkStatus[FSSdkStatus["SDK_INITIALIZING"] = 1] = "SDK_INITIALIZING";
    /**
     * Flagship SDK is ready but is running in Panic mode: All features are disabled except the one which refresh this status.
     */
    FSSdkStatus[FSSdkStatus["SDK_PANIC"] = 2] = "SDK_PANIC";
    /**
     * The Initialization is done, and Flagship SDK is ready to use.
     */
    FSSdkStatus[FSSdkStatus["SDK_INITIALIZED"] = 3] = "SDK_INITIALIZED";
})(FSSdkStatus || (FSSdkStatus = {}));

;// ./src/config/DecisionMode.ts
var DecisionMode;
(function (DecisionMode) {
    /**
     *   /**
     * Flagship SDK mode decision api
     */
    DecisionMode["DECISION_API"] = "DECISION-API";
    /**
     * Flagship SDK mode bucketing
     */
    DecisionMode["BUCKETING"] = "BUCKETING";
    DecisionMode["BUCKETING_EDGE"] = "BUCKETING_EDGE";
})(DecisionMode || (DecisionMode = {}));

;// ./src/enum/LogLevel.ts
var LogLevel;
(function (LogLevel) {
    /**
       * NONE = 0: Logging will be disabled.
       */
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
    /**
       * EMERGENCY = 1: Only emergencies will be logged.
       */
    LogLevel[LogLevel["EMERGENCY"] = 1] = "EMERGENCY";
    /**
       * ALERT = 2: Only alerts and above will be logged.
       */
    LogLevel[LogLevel["ALERT"] = 2] = "ALERT";
    /**
       * CRITICAL = 3: Only critical and above will be logged.
       */
    LogLevel[LogLevel["CRITICAL"] = 3] = "CRITICAL";
    /**
       * ERROR = 4: Only errors and above will be logged.
       */
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    /**
       * WARNING = 5: Only warnings and above will be logged.
       */
    LogLevel[LogLevel["WARNING"] = 5] = "WARNING";
    /**
       * NOTICE = 6: Only notices and above will be logged.
       */
    LogLevel[LogLevel["NOTICE"] = 6] = "NOTICE";
    /**
       * INFO = 7: Only info logs and above will be logged.
       */
    LogLevel[LogLevel["INFO"] = 7] = "INFO";
    /**
       * DEBUG = 8: Only debug logs and above will be logged.
       */
    LogLevel[LogLevel["DEBUG"] = 8] = "DEBUG";
    /**
       * ALL = 9: All logs will be logged.
       */
    LogLevel[LogLevel["ALL"] = 9] = "ALL";
})(LogLevel || (LogLevel = {}));

;// ./src/enum/FSFetchReasons.ts
/**
 * Enum representing the reasons for fetching Flags.
 */
var FSFetchReasons;
(function (FSFetchReasons) {
    /**
     * Indicates that a context has been updated or changed.
     */
    FSFetchReasons["UPDATE_CONTEXT"] = "UPDATE_CONTEXT";
    /**
     * Indicates that the XPC method 'authenticate' has been called.
     */
    FSFetchReasons["AUTHENTICATE"] = "AUTHENTICATE";
    /**
     * Indicates that the XPC method 'unauthenticate' has been called.
     */
    FSFetchReasons["UNAUTHENTICATE"] = "UNAUTHENTICATE";
    /**
     * Indicates that fetching flags has failed.
     */
    FSFetchReasons["FLAGS_FETCHING_ERROR"] = "FLAGS_FETCHING_ERROR";
    /**
     * Indicates that flags have been fetched from the cache.
     */
    FSFetchReasons["FLAGS_FETCHED_FROM_CACHE"] = "FLAGS_FETCHED_FROM_CACHE";
    /**
     * Indicates that the visitor has been created.
     */
    FSFetchReasons["FLAGS_NEVER_FETCHED"] = "FLAGS_NEVER_FETCHED";
    /**
     * Indicates that there is no specific reason for fetching flags.
     */
    FSFetchReasons["NONE"] = "NONE";
})(FSFetchReasons || (FSFetchReasons = {}));

;// ./src/utils/utils.ts


/**
 * Return a formatted string
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function sprintf(format, ...value) {
    let formatted = format;
    for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const element = typeof item === 'string' ? item : JSON.stringify(item instanceof Map ? Array.from(item.values()) : item);
        formatted = formatted.replace(new RegExp(`\\{${i}\\}`, 'g'), element);
    }
    return formatted;
}
function logErrorSprintf(config, tag, message, ...arg) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.ERROR) {
        return;
    }
    const customMessage = sprintf(message, ...arg);
    logError(config, customMessage, tag);
}
function logError(config, message, tag) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.ERROR) {
        return;
    }
    if (typeof config.onLog === 'function') {
        config.onLog(LogLevel.ERROR, tag, message);
    }
    if (config.logManager && typeof config.logManager.error === 'function') {
        config.logManager.error(message, tag);
    }
}
function logWarningSprintf(config, tag, message, ...arg) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.WARNING) {
        return;
    }
    const customMessage = sprintf(message, ...arg);
    logWarning(config, customMessage, tag);
}
function logWarning(config, message, tag) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.WARNING) {
        return;
    }
    if (typeof config.onLog === 'function') {
        config.onLog(LogLevel.WARNING, tag, message);
    }
    if (config.logManager && typeof config.logManager.warning === 'function') {
        config.logManager.warning(message, tag);
    }
}
function logInfoSprintf(config, tag, message, ...arg) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.INFO) {
        return;
    }
    const customMessage = sprintf(message, ...arg);
    logInfo(config, customMessage, tag);
}
function logInfo(config, message, tag) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.INFO) {
        return;
    }
    if (typeof config.onLog === 'function') {
        config.onLog(LogLevel.INFO, tag, message);
    }
    if (config.logManager && typeof config.logManager.info === 'function') {
        config.logManager.info(message, tag);
    }
}
function logDebugSprintf(config, tag, message, ...arg) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.DEBUG) {
        return;
    }
    const customMessage = sprintf(message, ...arg);
    logDebug(config, customMessage, tag);
}
function logDebug(config, message, tag) {
    if (!config || !config.logLevel || config.logLevel < LogLevel.DEBUG) {
        return;
    }
    if (typeof config.onLog === 'function') {
        config.onLog(LogLevel.DEBUG, tag, message);
    }
    if (config.logManager && typeof config.logManager.debug === 'function') {
        config.logManager.debug(message, tag);
    }
}
function isBrowser() {
    return typeof window !== 'undefined' && typeof window.document !== 'undefined';
}
function hasSameType(flagValue, defaultValue) {
    if (typeof flagValue !== typeof defaultValue) {
        return false;
    }
    if (typeof flagValue === 'object' && typeof defaultValue === 'object' &&
        Array.isArray(flagValue) !== Array.isArray(defaultValue)) {
        return false;
    }
    return true;
}
function uuidV4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {
        const rand = Math.random() * 16 | 0;
        const value = char === 'x' ? rand : (rand & 0x3 | 0x8);
        return value.toString(16);
    });
}
function errorFormat(message, errorData) {
    return JSON.stringify({
        message,
        data: errorData
    });
}
function visitorFlagSyncStatusMessage(reason) {
    let message = '';
    switch (reason) {
        case FSFetchReasons.FLAGS_NEVER_FETCHED:
            message = `Visitor \`{0}\` has been created ${VISITOR_SYNC_FLAGS_MESSAGE}`;
            break;
        case FSFetchReasons.UPDATE_CONTEXT:
            message = `Visitor context for visitor \`{0}\` has been updated ${VISITOR_SYNC_FLAGS_MESSAGE}`;
            break;
        case FSFetchReasons.AUTHENTICATE:
            message = `Visitor \`{0}\` has been authenticated ${VISITOR_SYNC_FLAGS_MESSAGE}`;
            break;
        case FSFetchReasons.UNAUTHENTICATE:
            message = `Visitor \`{0}\` has been unauthenticated ${VISITOR_SYNC_FLAGS_MESSAGE}`;
            break;
        case FSFetchReasons.FLAGS_FETCHING_ERROR:
            message = 'There was an error while fetching flags for visitor `{0}`. So the value of the flag `{1}` may be outdated"';
            break;
        case FSFetchReasons.FLAGS_FETCHED_FROM_CACHE:
            message = 'Flags for visitor `{0}` have been fetched from cache';
            break;
        default:
            break;
    }
    return message;
}
function valueToHex(value) {
    const jsonString = JSON.stringify(value);
    const hex = Array.from(jsonString, char => char.charCodeAt(0).toString(16)).join('');
    return hex;
}
function hexToValue(hex, config) {
    if (typeof hex !== 'string') {
        logErrorSprintf(config, 'hexToValue', 'Invalid hex string: {0}', hex);
        return null;
    }
    let jsonString = '';
    for (let i = 0; i < hex.length; i += 2) {
        const hexChar = hex.slice(i, i + 2);
        const charCode = parseInt(hexChar, 16);
        if (isNaN(charCode)) {
            logErrorSprintf(config, 'hexToValue', 'Invalid hex character: {0}', hexChar);
            return null;
        }
        jsonString += String.fromCharCode(charCode);
    }
    try {
        const value = JSON.parse(jsonString);
        return value;
    }
    catch (error) {
        logErrorSprintf(config, 'hexToValue', 'Error while parsing JSON: {0}', error);
        return null;
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function deepEqual(obj1, obj2) {
    if (obj1 === obj2)
        return true;
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 == null || obj2 == null) {
        return false;
    }
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
        return false;
    for (const key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }
    return true;
}
function onDomReady(callback) {
    if (false) {}
    return false;
}
function formatLogOutput(level, message, tag) {
    const now = new Date();
    const formatTwoDigits = (value) => {
        return value.toString().padStart(2, '0');
    };
    const formatMilliseconds = (value) => {
        return value.toString().padStart(3, '0');
    };
    const colorCodes = {
        [LogLevel.EMERGENCY]: '\x1b[1;37;41m',
        [LogLevel.ALERT]: '\x1b[1;37;45m',
        [LogLevel.CRITICAL]: '\x1b[1;37;41m',
        [LogLevel.ERROR]: '\x1b[1;37;41m',
        [LogLevel.WARNING]: '\x1b[33;1m',
        [LogLevel.NOTICE]: '\x1b[36;1m',
        [LogLevel.INFO]: '\x1b[32;1m',
        [LogLevel.DEBUG]: '\x1b[90;1m',
        [LogLevel.NONE]: '',
        [LogLevel.ALL]: '\x1b[90;1m'
    };
    const resetColor = '\x1b[0m';
    const colorCode = colorCodes[level] || '';
    const year = now.getFullYear();
    const month = formatTwoDigits(now.getMonth() + 1);
    const day = formatTwoDigits(now.getDate());
    const hours = formatTwoDigits(now.getHours());
    const minutes = formatTwoDigits(now.getMinutes());
    const seconds = formatTwoDigits(now.getSeconds());
    const milliseconds = formatMilliseconds(now.getMilliseconds());
    const timestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;
    const levelName = LogLevel[level].padEnd(2);
    return `${colorCode}[${timestamp}] [${FLAGSHIP_SDK}] [${levelName}] [${tag}] ${message}${resetColor}`;
}

;// ./src/enum/CacheStrategy.ts
/**
 * Define the strategy that will be used for hit caching
 */
var CacheStrategy;
(function (CacheStrategy) {
    /**
     * When a hit is emitted, it will be first cached in database using IHitCacheImplementation and added into the pool, then after batching and sending, it will also be flushed from database using IHitCacheImplementation.
     *
     * Note: the SDK has a default cache implementation for browser using localStorage
     */
    CacheStrategy[CacheStrategy["CONTINUOUS_CACHING"] = 0] = "CONTINUOUS_CACHING";
    /**
     * When a hit is emitted, it will be added into the pool, then after batching and sending, all database hits will be flushed, then the entire pool will be cached using IHitCacheImplementation for both actions.
     */
    CacheStrategy[CacheStrategy["PERIODIC_CACHING"] = 1] = "PERIODIC_CACHING";
})(CacheStrategy || (CacheStrategy = {}));

;// ./src/config/TrackingManagerConfig.ts


class TrackingManagerConfig {
    _batchIntervals;
    _poolMaxSize;
    _batchStrategy;
    constructor(param) {
        this.batchIntervals = param?.batchIntervals;
        this.poolMaxSize = param?.poolMaxSize;
        this._batchStrategy = this.getCacheStrategy(param?.cacheStrategy);
    }
    getCacheStrategy(cacheStrategy) {
        if (typeof cacheStrategy === 'number') {
            return cacheStrategy;
        }
        return (isBrowser() ? CacheStrategy.CONTINUOUS_CACHING : CacheStrategy.PERIODIC_CACHING);
    }
    get batchIntervals() {
        return this._batchIntervals;
    }
    set batchIntervals(v) {
        if (typeof v !== 'number' || v < 0 || v > 10800) {
            v = isBrowser() ? DEFAULT_BROWSER_TIME_INTERVAL : DEFAULT_SERVER_TIME_INTERVAL;
        }
        this._batchIntervals = v;
    }
    get poolMaxSize() {
        return this._poolMaxSize;
    }
    set poolMaxSize(v) {
        if (typeof v !== 'number' || v < 5) {
            v = isBrowser() ? DEFAULT_BROWSER_POOL_MAX_SIZE : DEFAULT_SERVER_POOL_MAX_SIZE;
        }
        this._poolMaxSize = v;
    }
    get cacheStrategy() {
        return this._batchStrategy;
    }
}

;// ./src/config/FlagshipConfig.ts





const statusChangeError = 'statusChangedCallback must be a function';
class FlagshipConfig {
    _envId;
    _apiKey;
    _decisionMode;
    _timeout;
    _logLevel;
    _onSdkStatusChanged;
    _logManager;
    _fetchNow;
    _pollingInterval;
    _onBucketingUpdated;
    _reuseVisitorIds;
    _initialBucketing;
    _decisionApiUrl;
    _hitDeduplicationTime;
    _visitorCacheImplementation;
    _hitCacheImplementation;
    _disableCache;
    _trackingManagerConfig;
    _onVisitorExposed;
    _fetchThirdPartyData;
    _nextFetchConfig;
    _fetchFlagsBufferingTime;
    _disableDeveloperUsageTracking;
    _onLog;
    _isQAModeEnabled;
    _batchActivateHits = false;
    get batchActivateHits() {
        return this._batchActivateHits;
    }
    set batchActivateHits(v) {
        this._batchActivateHits = v;
    }
    get isQAModeEnabled() {
        return this._isQAModeEnabled;
    }
    set isQAModeEnabled(v) {
        this._isQAModeEnabled = v;
    }
    _enableAnalytics;
    get disableDeveloperUsageTracking() {
        return this._disableDeveloperUsageTracking;
    }
    set disableDeveloperUsageTracking(v) {
        this._disableDeveloperUsageTracking = v;
    }
    get fetchFlagsBufferingTime() {
        return this._fetchFlagsBufferingTime;
    }
    set fetchFlagsBufferingTime(v) {
        this._fetchFlagsBufferingTime = v;
    }
    get nextFetchConfig() {
        return this._nextFetchConfig;
    }
    set nextFetchConfig(v) {
        this._nextFetchConfig = v;
    }
    get fetchThirdPartyData() {
        return this._fetchThirdPartyData;
    }
    set fetchThirdPartyData(v) {
        this._fetchThirdPartyData = v;
    }
    get trackingManagerConfig() {
        return this._trackingManagerConfig;
    }
    get onLog() {
        return this._onLog;
    }
    set onLog(v) {
        this._onLog = v;
    }
    get onVisitorExposed() {
        return this._onVisitorExposed;
    }
    constructor(param) {
        const { envId, apiKey, timeout, logLevel, logManager, onSdkStatusChanged, fetchNow, decisionMode, reuseVisitorIds, initialBucketing, decisionApiUrl, hitDeduplicationTime, visitorCacheImplementation, hitCacheImplementation, disableCache, language, sdkVersion, trackingManagerConfig, onLog, onVisitorExposed, nextFetchConfig, fetchFlagsBufferingTime, disableDeveloperUsageTracking, batchActivateHits } = param;
        this.initQaMode();
        this.initSDKInfo(language, sdkVersion);
        if (logManager) {
            this.logManager = logManager;
        }
        this._batchActivateHits = batchActivateHits;
        this.fetchFlagsBufferingTime = fetchFlagsBufferingTime ?? FETCH_FLAG_BUFFERING_DEFAULT_TIME;
        this.nextFetchConfig = nextFetchConfig || { revalidate: 20 };
        this._trackingManagerConfig = new TrackingManagerConfig(trackingManagerConfig || {});
        this.onLog = onLog;
        this.decisionApiUrl = decisionApiUrl || BASE_API_URL;
        this._envId = envId;
        this._apiKey = apiKey;
        this.logLevel = logLevel ?? LogLevel.INFO;
        this.timeout = timeout || REQUEST_TIME_OUT;
        this.setFetchNow(fetchNow);
        this.reuseVisitorIds = typeof reuseVisitorIds === 'undefined' || reuseVisitorIds;
        this._decisionMode = decisionMode || DecisionMode.DECISION_API;
        this._initialBucketing = initialBucketing;
        this.hitDeduplicationTime = hitDeduplicationTime ?? DEFAULT_DEDUPLICATION_TIME;
        this.disableCache = !!disableCache;
        this.disableDeveloperUsageTracking = disableDeveloperUsageTracking || false;
        if (visitorCacheImplementation) {
            this.visitorCacheImplementation = visitorCacheImplementation;
        }
        if (hitCacheImplementation) {
            this.hitCacheImplementation = hitCacheImplementation;
        }
        this.onSdkStatusChanged = onSdkStatusChanged;
        this._onVisitorExposed = onVisitorExposed;
    }
    setFetchNow(fetchNow) {
        if (true) {
            this.fetchNow = typeof fetchNow === 'undefined' ? true : fetchNow;
        }
        else {}
    }
    initQaMode() {
        if (false) {}
    }
    initSDKInfo(language, sdkVersion) {
        switch (language) {
            case 1:
                SDK_INFO.name = 'ReactJS';
                SDK_INFO.version = sdkVersion ?? sdkVersion_version;
                break;
            case 2:
                SDK_INFO.name = 'React-Native';
                SDK_INFO.version = sdkVersion ?? sdkVersion_version;
                break;
            default:
                SDK_INFO.name = (typeof window !== 'undefined' && 'Deno' in window) ? 'Deno' : 'TypeScript';
                SDK_INFO.version = sdkVersion_version;
                break;
        }
    }
    get initialBucketing() {
        return this._initialBucketing;
    }
    set initialBucketing(v) {
        this._initialBucketing = v;
    }
    get reuseVisitorIds() {
        return this._reuseVisitorIds;
    }
    set reuseVisitorIds(v) {
        this._reuseVisitorIds = v;
    }
    get onBucketingUpdated() {
        return this._onBucketingUpdated;
    }
    set onBucketingUpdated(v) {
        this._onBucketingUpdated = v;
    }
    set envId(value) {
        this._envId = value;
    }
    get envId() {
        return this._envId;
    }
    set apiKey(value) {
        this._apiKey = value;
    }
    get apiKey() {
        return this._apiKey;
    }
    get decisionMode() {
        return this._decisionMode;
    }
    get timeout() {
        return this._timeout;
    }
    set timeout(value) {
        this._timeout = value;
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(value) {
        this._logLevel = value;
    }
    get fetchNow() {
        return this._fetchNow;
    }
    set fetchNow(v) {
        this._fetchNow = v;
    }
    get pollingInterval() {
        return this._pollingInterval;
    }
    set pollingInterval(v) {
        this._pollingInterval = v;
    }
    get hitDeduplicationTime() {
        return this._hitDeduplicationTime;
    }
    set hitDeduplicationTime(v) {
        if (typeof v !== 'number') {
            logError(this, sprintf(TYPE_ERROR, 'hitDeduplicationTime', 'number'), 'hitDeduplicationTime');
            return;
        }
        this._hitDeduplicationTime = v;
    }
    get visitorCacheImplementation() {
        return this._visitorCacheImplementation;
    }
    set visitorCacheImplementation(v) {
        this._visitorCacheImplementation = v;
    }
    get hitCacheImplementation() {
        return this._hitCacheImplementation;
    }
    set hitCacheImplementation(v) {
        this._hitCacheImplementation = v;
    }
    get disableCache() {
        return this._disableCache;
    }
    set disableCache(v) {
        this._disableCache = v;
    }
    get onSdkStatusChanged() {
        return this._onSdkStatusChanged;
    }
    set onSdkStatusChanged(fn) {
        if (fn && typeof fn !== 'function') {
            logError(this, statusChangeError, 'onSdkStatusChanged');
            return;
        }
        this._onSdkStatusChanged = fn;
    }
    get logManager() {
        return this._logManager;
    }
    set logManager(value) {
        this._logManager = value;
    }
    get decisionApiUrl() {
        return this._decisionApiUrl;
    }
    set decisionApiUrl(v) {
        if (typeof v !== 'string') {
            logError(this, sprintf(TYPE_ERROR, 'decisionApiUrl', 'string'), 'decisionApiUrl');
            return;
        }
        this._decisionApiUrl = v;
    }
}

;// ./src/config/BucketingConfig.ts



class BucketingConfig extends FlagshipConfig {
    constructor(param) {
        super({
            ...param,
            decisionMode: DecisionMode.BUCKETING
        });
        this.pollingInterval = param?.pollingInterval ?? DEFAULT_POLLING_INTERVAL;
        this.onBucketingUpdated = param?.onBucketingUpdated;
        this.fetchThirdPartyData = param?.fetchThirdPartyData;
    }
}

;// ./src/config/DecisionApiConfig.ts


class DecisionApiConfig extends FlagshipConfig {
    constructor(param) {
        super({
            ...param,
            decisionMode: DecisionMode.DECISION_API
        });
    }
}

;// ./src/config/ConfigManager.ts
class ConfigManager {
    _config;
    _decisionManager;
    _trackingManager;
    _sharedActionTracking;
    constructor(config, decisionManager, trackingManager, sharedActionTracking) {
        this._config = config;
        this._decisionManager = decisionManager;
        this._trackingManager = trackingManager;
        this._sharedActionTracking = sharedActionTracking;
    }
    get config() {
        return this._config;
    }
    set config(value) {
        this._config = value;
    }
    get decisionManager() {
        return this._decisionManager;
    }
    set decisionManager(value) {
        this._decisionManager = value;
    }
    get trackingManager() {
        return this._trackingManager;
    }
    set trackingManager(value) {
        this._trackingManager = value;
    }
    get sharedActionTracking() {
        return this._sharedActionTracking;
    }
}

;// ./src/types.ts
var TroubleshootingLabel;
(function (TroubleshootingLabel) {
    TroubleshootingLabel["VISITOR_SEND_HIT"] = "VISITOR_SEND_HIT";
    TroubleshootingLabel["VISITOR_FETCH_CAMPAIGNS_ERROR"] = "VISITOR_FETCH_CAMPAIGNS_ERROR";
    TroubleshootingLabel["VISITOR_FETCH_CAMPAIGNS"] = "VISITOR_FETCH_CAMPAIGNS";
    TroubleshootingLabel["VISITOR_AUTHENTICATE"] = "VISITOR_AUTHENTICATE";
    TroubleshootingLabel["VISITOR_UNAUTHENTICATE"] = "VISITOR_UNAUTHENTICATE";
    TroubleshootingLabel["VISITOR_EXPOSED_FLAG_NOT_FOUND"] = "VISITOR_EXPOSED_FLAG_NOT_FOUND";
    TroubleshootingLabel["FLAG_VALUE_NOT_CALLED"] = "FLAG_VALUE_NOT_CALLED";
    TroubleshootingLabel["GET_FLAG_VALUE_FLAG_NOT_FOUND"] = "GET_FLAG_VALUE_FLAG_NOT_FOUND";
    TroubleshootingLabel["GET_FLAG_METADATA_TYPE_WARNING"] = "GET_FLAG_METADATA_TYPE_WARNING";
    TroubleshootingLabel["GET_FLAG_VALUE_TYPE_WARNING"] = "GET_FLAG_VALUE_TYPE_WARNING";
    TroubleshootingLabel["VISITOR_EXPOSED_TYPE_WARNING"] = "VISITOR_EXPOSED_TYPE_WARNING";
    TroubleshootingLabel["VISITOR_SEND_ACTIVATE"] = "VISITOR_SEND_ACTIVATE";
    TroubleshootingLabel["GET_CAMPAIGNS_ROUTE_RESPONSE_ERROR"] = "GET_CAMPAIGNS_ROUTE_RESPONSE_ERROR";
    TroubleshootingLabel["GET_CAMPAIGNS_ROUTE_RESPONSE"] = "GET_CAMPAIGNS_ROUTE_RESPONSE";
    TroubleshootingLabel["SDK_BUCKETING_FILE"] = "SDK_BUCKETING_FILE";
    TroubleshootingLabel["SEND_ACTIVATE_HIT_ROUTE_ERROR"] = "SEND_ACTIVATE_HIT_ROUTE_ERROR";
    TroubleshootingLabel["SEND_BATCH_HIT_ROUTE_RESPONSE_ERROR"] = "SEND_BATCH_HIT_ROUTE_RESPONSE_ERROR";
    TroubleshootingLabel["SEND_HIT_ROUTE_ERROR"] = "SEND_HIT_ROUTE_ERROR";
    TroubleshootingLabel["SDK_BUCKETING_FILE_ERROR"] = "SDK_BUCKETING_FILE_ERROR";
    TroubleshootingLabel["SDK_CONFIG"] = "SDK_CONFIG";
    TroubleshootingLabel["ACCOUNT_SETTINGS"] = "ACCOUNT_SETTINGS";
    TroubleshootingLabel["ACCOUNT_SETTINGS_ERROR"] = "ACCOUNT_SETTINGS_ERROR";
    TroubleshootingLabel["EMOTION_AI_SCORE"] = "EMOTION_EAI_SCORE";
    TroubleshootingLabel["EMOTION_AI_SCORE_FROM_LOCAL_CACHE"] = "EMOTION_AI_SCORE_FROM_LOCAL_CACHE";
    TroubleshootingLabel["EMOTION_AI_SCORE_ERROR"] = "EMOTION_EAI_SCORE_ERROR";
    TroubleshootingLabel["EMOTION_AI_VISITOR_EVENT"] = "EMOTION_AI_VISITOR_EVENT";
    TroubleshootingLabel["EMOTION_AI_VISITOR_EVENT_ERROR"] = "EMOTION_AI_VISITOR_EVENT_ERROR";
    TroubleshootingLabel["EMOTION_AI_PAGE_VIEW"] = "EMOTION_AI_PAGE_VIEW";
    TroubleshootingLabel["EMOTION_AI_PAGE_VIEW_ERROR"] = "EMOTION_AI_PAGE_VIEW_ERROR";
    TroubleshootingLabel["EMOTION_AI_START_COLLECTING"] = "EMOTION_AI_START_COLLECTING";
    TroubleshootingLabel["EMOTION_AI_STOP_COLLECTING"] = "EMOTION_AI_STOP_COLLECTING";
    TroubleshootingLabel["EMOTION_AI_START_SCORING"] = "EMOTION_AI_START_SCORING";
    TroubleshootingLabel["EMOTION_AI_SCORING_FAILED"] = "EMOTION_AI_SCORING_FAILED";
    TroubleshootingLabel["EMOTION_AI_SCORING_SUCCESS"] = "EMOTION_AI_SCORING_SUCCESS";
})(TroubleshootingLabel || (TroubleshootingLabel = {}));
var VisitorCacheStatus;
(function (VisitorCacheStatus) {
    VisitorCacheStatus["NONE"] = "NONE";
    VisitorCacheStatus["ANONYMOUS_ID_CACHE"] = "ANONYMOUS_ID_CACHE";
    VisitorCacheStatus["VISITOR_ID_CACHE"] = "VISITOR_ID_CACHE";
    VisitorCacheStatus["VISITOR_ID_CACHE_WITH_ANONYMOUS_ID_CACHE"] = "VISITOR_ID_CACHE_WITH_ANONYMOUS_ID_CACHE";
})(VisitorCacheStatus || (VisitorCacheStatus = {}));
var ABTastyWebSDKPostMessageType;
(function (ABTastyWebSDKPostMessageType) {
    ABTastyWebSDKPostMessageType["AB_TASTY_WEB_SDK_INITIALIZED"] = "AB_TASTY_WEB_SDK_INITIALIZED";
})(ABTastyWebSDKPostMessageType || (ABTastyWebSDKPostMessageType = {}));

;// ./src/hit/HitAbstract.ts


class HitAbstract {
    _visitorId;
    _config;
    _type;
    _ds;
    _anonymousId;
    _userIp;
    _screenResolution;
    _locale;
    _sessionNumber;
    _key;
    _createdAt;
    _qaMode;
    _isActionTrackingHit;
    get isActionTrackingHit() {
        return this._isActionTrackingHit;
    }
    set isActionTrackingHit(v) {
        this._isActionTrackingHit = v;
    }
    get key() {
        return this._key;
    }
    set key(v) {
        this._key = v;
    }
    get sessionNumber() {
        return this._sessionNumber;
    }
    set sessionNumber(v) {
        this._sessionNumber = v;
    }
    get locale() {
        return this._locale;
    }
    set locale(v) {
        this._locale = v;
    }
    get screenResolution() {
        return this._screenResolution;
    }
    set screenResolution(v) {
        this._screenResolution = v;
    }
    get userIp() {
        return this._userIp;
    }
    set userIp(v) {
        this._userIp = v;
    }
    get anonymousId() {
        return this._anonymousId;
    }
    set anonymousId(v) {
        this._anonymousId = v;
    }
    get visitorId() {
        return this._visitorId;
    }
    set visitorId(v) {
        this._visitorId = v;
    }
    get ds() {
        return this._ds;
    }
    set ds(v) {
        this._ds = v;
    }
    get type() {
        return this._type;
    }
    get config() {
        return this._config;
    }
    set config(v) {
        this._config = v;
    }
    get createdAt() {
        return this._createdAt;
    }
    set createdAt(v) {
        this._createdAt = v;
    }
    get qaMode() {
        return this._qaMode;
    }
    set qaMode(v) {
        this._qaMode = v;
    }
    constructor(hit) {
        const { type, userIp, screenResolution, locale, sessionNumber, visitorId, anonymousId, ds, qaMode, isActionTrackingHit } = hit;
        this._type = type;
        if (userIp) {
            this.userIp = userIp;
        }
        if (screenResolution) {
            this.screenResolution = screenResolution;
        }
        if (locale) {
            this.locale = locale;
        }
        if (sessionNumber) {
            this.sessionNumber = sessionNumber;
        }
        this.visitorId = visitorId;
        this._anonymousId = anonymousId || null;
        this.createdAt = Date.now();
        this.ds = ds || SDK_APP;
        this.qaMode = qaMode;
        this.isActionTrackingHit = isActionTrackingHit;
    }
    /**
     * Return true if value is a string and not empty, otherwise return false
     * @param value
     * @param itemName
     * @returns
     */
    isNotEmptyString(value, itemName) {
        if (!value || typeof value !== 'string') {
            logError(this.config, sprintf(TYPE_ERROR, itemName, 'string'), itemName);
            return false;
        }
        return true;
    }
    isNumeric(value, itemName) {
        if (!value || typeof value !== 'number') {
            logError(this.config, sprintf(TYPE_ERROR, itemName, 'number'), itemName);
            return false;
        }
        return true;
    }
    isInteger(value, itemName) {
        if (!Number.isInteger(value)) {
            logError(this.config, sprintf(TYPE_ERROR, itemName, 'integer'), itemName);
            return false;
        }
        return true;
    }
    /**
     * Return an object with Api parameters as keys
     */
    toApiKeys() {
        const apiKeys = {
            [VISITOR_ID_API_ITEM]: this.visitorId,
            [DS_API_ITEM]: this.ds,
            [CUSTOMER_ENV_ID_API_ITEM]: `${this.config?.envId}`,
            [T_API_ITEM]: this.type,
            [CUSTOMER_UID]: null,
            [QT_API_ITEM]: Date.now() - this._createdAt
        };
        if (this.qaMode) {
            apiKeys[QA_MODE_API_ITEM] = true;
        }
        if (this.userIp) {
            apiKeys[USER_IP_API_ITEM] = this.userIp;
        }
        if (this.screenResolution) {
            apiKeys[SCREEN_RESOLUTION_API_ITEM] = this.screenResolution;
        }
        if (this.locale) {
            apiKeys[USER_LANGUAGE] = this.locale;
        }
        if (this.sessionNumber) {
            apiKeys[SESSION_NUMBER] = this.sessionNumber;
        }
        if (this.visitorId && this.anonymousId) {
            apiKeys[VISITOR_ID_API_ITEM] = this.anonymousId;
            apiKeys[CUSTOMER_UID] = this.visitorId;
        }
        return apiKeys;
    }
    toObject() {
        return {
            key: this.key,
            visitorId: this.visitorId,
            ds: this.ds,
            type: this.type,
            userIp: this.userIp,
            screenResolution: this.screenResolution,
            locale: this.locale,
            sessionNumber: this.sessionNumber,
            anonymousId: this.anonymousId,
            createdAt: this.createdAt,
            qaMode: this.qaMode
        };
    }
    /**
     * Return true if all required attributes are given, otherwise return false
     */
    isReady(_checkParent = true) {
        return !!(this.visitorId &&
            this.ds &&
            this.config &&
            this.config.envId &&
            this.type);
    }
}

;// ./src/enum/BatchTriggeredBy.ts
var BatchTriggeredBy;
(function (BatchTriggeredBy) {
    BatchTriggeredBy[BatchTriggeredBy["Timer"] = 0] = "Timer";
    BatchTriggeredBy[BatchTriggeredBy["BatchLength"] = 1] = "BatchLength";
    BatchTriggeredBy[BatchTriggeredBy["Flush"] = 2] = "Flush";
    BatchTriggeredBy[BatchTriggeredBy["ActivateLength"] = 3] = "ActivateLength";
    BatchTriggeredBy[BatchTriggeredBy["DirectHit"] = 4] = "DirectHit";
    BatchTriggeredBy[BatchTriggeredBy["DirectActivate"] = 5] = "DirectActivate";
})(BatchTriggeredBy || (BatchTriggeredBy = {}));

;// ./src/hit/Diagnostic.ts




const ERROR_MESSAGE = 'event category and event action are required';
/**
 * Represents a diagnostic hit.
 */
class Diagnostic extends HitAbstract {
    data;
    _traffic;
    get traffic() {
        return this._traffic;
    }
    set traffic(v) {
        this._traffic = v;
    }
    constructor(param) {
        super({
            type: param.type,
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId
        });
        this.data = {
            ...param,
            version: param.version || '1',
            stackType: param.stackType || 'SDK',
            stackName: param.stackName || SDK_INFO.name,
            stackVersion: param.stackVersion || SDK_INFO.version,
            label: param.label,
            logLevel: param.logLevel,
            timestamp: param.timestamp || new Date(Date.now()).toISOString(),
            timeZone: this.getTimezone(),
            ds: SDK_APP,
            envId: param.envId || param.config.envId
        };
        this._traffic = param.traffic;
        this.config = param.config;
    }
    /**
     * Gets the timezone of the user.
     * @returns The timezone as a string. If the timezone cannot be determined, it returns the offset from UTC in hours.
     */
    getTimezone() {
        const timezone = typeof Intl === 'object' ? Intl.DateTimeFormat()?.resolvedOptions()?.timeZone : undefined;
        return timezone || `${new Date().getTimezoneOffset() / 60}`;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, complexity
    toApiKeys() {
        const apiKeys = {
            [VISITOR_ID_API_ITEM]: this.visitorId,
            [DS_API_ITEM]: this.data.ds,
            [CUSTOMER_ENV_ID_API_ITEM]: `${this.data.config?.envId}`,
            [T_API_ITEM]: this.type,
            cv: {}
        };
        const customVariable = {
            version: `${this.data.version}`,
            logLevel: `${LogLevel[this.data.logLevel]}`,
            timestamp: `${this.data.timestamp}`,
            timeZone: `${this.data.timeZone}`,
            label: `${this.data.label}`,
            'stack.type': `${this.data.stackType}`,
            'stack.name': `${this.data.stackName}`,
            'stack.version': `${this.data.stackVersion}`
        };
        if (this.data.lastBucketingTimestamp !== undefined) {
            customVariable.lastBucketingTimestamp = `${this.data.lastBucketingTimestamp}`;
        }
        if (this.data.lastInitializationTimestamp !== undefined) {
            customVariable.lastInitializationTimestamp = `${this.data.lastInitializationTimestamp}`;
        }
        if (this.data.flagshipInstanceId !== undefined) {
            customVariable.flagshipInstanceId = `${this.data.flagshipInstanceId}`;
        }
        if (this.data.accountId) {
            customVariable.accountId = `${this.data.accountId}`;
        }
        if (this.data.envId) {
            customVariable.envId = `${this.data.envId}`;
        }
        if (this.data.sdkBucketingFile !== undefined) {
            customVariable.sdkBucketingFile = JSON.stringify(this.data.sdkBucketingFile);
        }
        if (this.data.stackOriginName !== undefined) {
            customVariable['stack.origin.name'] = `${this.data.stackOriginName}`;
        }
        if (this.data.stackOriginVersion !== undefined) {
            customVariable['stack.origin.version'] = `${this.data.stackOriginVersion}`;
        }
        if (this.data.sdkStatus !== undefined) {
            customVariable['sdk.status'] = `${FSSdkStatus[this.data.sdkStatus]}`;
        }
        if (this.data.sdkConfigLogLevel !== undefined) {
            customVariable['sdk.config.logLevel'] = `${LogLevel[this.data.sdkConfigLogLevel]}`;
        }
        if (this.data.sdkConfigMode !== undefined) {
            customVariable['sdk.config.mode'] = `${this.data.sdkConfigMode}`;
        }
        if (this.data.sdkConfigCustomLogManager !== undefined) {
            customVariable['sdk.config.customLogManager'] = `${this.data.sdkConfigCustomLogManager}`;
        }
        if (this.data.sdkConfigCustomCacheManager !== undefined) {
            customVariable['sdk.config.customCacheManager'] = `${this.data.sdkConfigCustomCacheManager}`;
        }
        if (this.data.sdkConfigStatusListener !== undefined) {
            customVariable['sdk.config.custom.StatusListener'] = `${this.data.sdkConfigStatusListener}`;
        }
        if (this.data.sdkConfigTimeout !== undefined) {
            customVariable['sdk.config.timeout'] = `${this.data.sdkConfigTimeout * 1000}`;
        }
        if (this.data.sdkConfigPollingInterval !== undefined) {
            customVariable['sdk.config.pollingTime'] = `${this.data.sdkConfigPollingInterval * 1000}`;
        }
        if (this.data.sdkConfigTrackingManagerStrategy !== undefined) {
            customVariable['sdk.config.trackingManager.strategy'] = `${CacheStrategy[this.data.sdkConfigTrackingManagerStrategy]}`;
        }
        if (this.data.sdkConfigTrackingManagerBatchIntervals !== undefined) {
            customVariable['sdk.config.trackingManager.batchIntervals'] = `${this.data.sdkConfigTrackingManagerBatchIntervals * 1000}`;
        }
        if (this.data.sdkConfigTrackingManagerPoolMaxSize !== undefined) {
            customVariable['sdk.config.trackingManager.poolMaxSize'] = `${this.data.sdkConfigTrackingManagerPoolMaxSize}`;
        }
        if (this.data.sdkConfigFetchNow !== undefined) {
            customVariable['sdk.config.fetchNow'] = `${this.data.sdkConfigFetchNow}`;
        }
        if (this.data.sdkConfigReuseVisitorIds !== undefined) {
            customVariable['sdk.config.reuseVisitorIds'] = `${this.data.sdkConfigReuseVisitorIds}`;
        }
        if (this.data.sdkConfigInitialBucketing !== undefined) {
            customVariable['sdk.config.initialBucketing'] = JSON.stringify(this.data.sdkConfigInitialBucketing);
        }
        if (this.data.sdkConfigDecisionApiUrl !== undefined) {
            customVariable['sdk.config.decisionApiUrl'] = `${this.data.sdkConfigDecisionApiUrl}`;
        }
        if (this.data.sdkConfigHitDeduplicationTime !== undefined) {
            customVariable['sdk.config.hitDeduplicationTime'] = `${this.data.sdkConfigHitDeduplicationTime * 1000}`;
        }
        if (this.data.sdkConfigUsingCustomHitCache !== undefined) {
            customVariable['sdk.config.usingCustomHitCache'] = JSON.stringify(this.data.sdkConfigUsingCustomHitCache);
        }
        if (this.data.sdkConfigUsingCustomVisitorCache !== undefined) {
            customVariable['sdk.config.usingCustomVisitorCache'] = JSON.stringify(this.data.sdkConfigUsingCustomVisitorCache);
        }
        if (this.data.sdkConfigUsingOnVisitorExposed !== undefined) {
            customVariable['sdk.config.usingOnVisitorExposed'] = JSON.stringify(this.data.sdkConfigUsingOnVisitorExposed);
        }
        if (this.data.sdkConfigFetchThirdPartyData !== undefined) {
            customVariable['sdk.config.fetchThirdPartyData'] = JSON.stringify(this.data.sdkConfigFetchThirdPartyData);
        }
        if (this.data.sdkConfigFetchFlagsBufferingTime !== undefined) {
            customVariable['sdk.config.fetchFlagsBufferingTime'] = JSON.stringify(this.data.sdkConfigFetchFlagsBufferingTime * 1000);
        }
        if (this.data.sdkConfigNextFetchConfig !== undefined) {
            customVariable['sdk.config.nextFetchConfig'] = JSON.stringify(this.data.sdkConfigNextFetchConfig);
        }
        if (this.data.sdkConfigDisableDeveloperUsageTracking !== undefined) {
            customVariable['sdk.config.disableDeveloperUsageTracking'] = JSON.stringify(this.data.sdkConfigDisableDeveloperUsageTracking);
        }
        if (this.data.sdkConfigDisableCache !== undefined) {
            customVariable['sdk.config.disableCache'] = JSON.stringify(this.data.sdkConfigDisableCache);
        }
        if (this.data.httpRequestUrl !== undefined) {
            customVariable['http.request.url'] = `${this.data.httpRequestUrl}`;
        }
        if (this.data.httpRequestMethod !== undefined) {
            customVariable['http.request.method'] = `${this.data.httpRequestMethod}`;
        }
        if (this.data.httpRequestHeaders !== undefined) {
            customVariable['http.request.headers'] = JSON.stringify(this.data.httpRequestHeaders);
        }
        if (this.data.httpRequestBody !== undefined) {
            customVariable['http.request.body'] = JSON.stringify(this.data.httpRequestBody);
        }
        if (this.data.httpResponseUrl !== undefined) {
            customVariable['http.response.url'] = `${this.data.httpResponseUrl}`;
        }
        if (this.data.httpResponseMethod !== undefined) {
            customVariable['http.response.method'] = `${this.data.httpResponseMethod}`;
        }
        if (this.data.httpResponseHeaders !== undefined) {
            customVariable['http.response.headers'] = JSON.stringify(this.data.httpResponseHeaders);
        }
        if (this.data.httpResponseCode !== undefined) {
            customVariable['http.response.code'] = `${this.data.httpResponseCode}`;
        }
        if (this.data.httpResponseBody !== undefined) {
            customVariable['http.response.body'] = JSON.stringify(this.data.httpResponseBody);
        }
        if (this.data.httpResponseTime !== undefined) {
            customVariable['http.response.time'] = `${this.data.httpResponseTime}`;
        }
        if (this.visitorId !== undefined) {
            customVariable['visitor.visitorId'] = `${this.visitorId}`;
        }
        if (this.anonymousId !== undefined) {
            customVariable['visitor.anonymousId'] = `${this.anonymousId}`;
        }
        if (this.data.visitorSessionId !== undefined) {
            customVariable['visitor.sessionId'] = `${this.data.visitorSessionId}`;
        }
        if (this.data.visitorStatus !== undefined) {
            customVariable['visitor.status'] = `${this.data.visitorStatus}`;
        }
        if (this.data.visitorInstanceType !== undefined) {
            customVariable['visitor.instanceType'] = `${this.data.visitorInstanceType}`;
        }
        if (this.data.visitorContext !== undefined) {
            for (const key in this.data.visitorContext) {
                const element = this.data.visitorContext[key];
                customVariable[`visitor.context.[${key}]`] = `${element}`;
            }
        }
        if (this.data.visitorConsent !== undefined) {
            customVariable['visitor.consent'] = `${this.data.visitorConsent}`;
        }
        if (this.data.visitorAssignmentHistory !== undefined) {
            for (const key in this.data.visitorAssignmentHistory) {
                const element = this.data.visitorAssignmentHistory[key];
                customVariable[`visitor.assignments.[${key}]`] = element;
            }
        }
        if (this.data.visitorFlags !== undefined) {
            this.data.visitorFlags.forEach((item, flagKey) => {
                for (const itemKey in item) {
                    const itemValue = item[itemKey];
                    const hasMetadataKey = itemKey === 'value' || itemKey === 'key';
                    const value = typeof itemValue === 'string' ? itemValue : JSON.stringify(itemValue);
                    customVariable[`visitor.flags.[${flagKey}]${hasMetadataKey ? '' : '.metadata'}.${itemKey}`] = value;
                }
            });
        }
        if (this.data.visitorIsAuthenticated !== undefined) {
            customVariable['visitor.isAuthenticated'] = `${this.data.visitorIsAuthenticated}`;
        }
        if (this.data.visitorInitialCampaigns !== undefined) {
            customVariable['visitor.initialCampaigns'] = JSON.stringify(this.data.visitorInitialCampaigns);
        }
        if (this.data.visitorInitialFlagsData !== undefined) {
            customVariable['visitor.initialFlagsData'] = JSON.stringify(Array.isArray(this.data.visitorInitialFlagsData) ? this.data.visitorInitialFlagsData : Array.from(this.data.visitorInitialFlagsData));
        }
        if (this.data.visitorCampaigns !== undefined) {
            customVariable['visitor.campaigns'] = JSON.stringify(this.data.visitorCampaigns);
        }
        if (this.data.visitorCampaignFromCache !== undefined) {
            customVariable['visitor.campaignFromCache'] = JSON.stringify(this.data.visitorCampaignFromCache);
        }
        if (this.data.contextKey !== undefined) {
            customVariable.contextKey = `${this.data.contextKey}`;
        }
        if (this.data.contextValue !== undefined) {
            customVariable.contextValue = `${this.data.contextValue}`;
        }
        if (this.data.flagKey !== undefined) {
            customVariable['flag.key'] = `${this.data.flagKey}`;
        }
        if (this.data.flagValue !== undefined) {
            customVariable['flag.value'] = `${this.data.flagValue}`;
        }
        if (this.data.flagDefault !== undefined) {
            customVariable['flag.default'] = JSON.stringify(this.data.flagDefault);
        }
        if (this.data.flagMetadataCampaignId !== undefined) {
            customVariable['flag.metadata.campaignId'] = `${this.data.flagMetadataCampaignId}`;
        }
        if (this.data.flagMetadataCampaignName !== undefined) {
            customVariable['flag.metadata.campaignName'] = `${this.data.flagMetadataCampaignName}`;
        }
        if (this.data.flagMetadataVariationGroupId !== undefined) {
            customVariable['flag.metadata.variationGroupId'] = `${this.data.flagMetadataVariationGroupId}`;
        }
        if (this.data.flagMetadataVariationGroupName !== undefined) {
            customVariable['flag.metadata.variationGroupName'] = `${this.data.flagMetadataVariationGroupName}`;
        }
        if (this.data.flagMetadataVariationId !== undefined) {
            customVariable['flag.metadata.variationId'] = `${this.data.flagMetadataVariationId}`;
        }
        if (this.data.flagMetadataVariationName !== undefined) {
            customVariable['flag.metadata.variationName'] = `${this.data.flagMetadataVariationName}`;
        }
        if (this.data.flagMetadataCampaignSlug !== undefined) {
            customVariable['flag.metadata.campaignSlug'] = `${this.data.flagMetadataCampaignSlug}`;
        }
        if (this.data.flagMetadataCampaignType !== undefined) {
            customVariable['flag.metadata.campaignType'] = `${this.data.flagMetadataCampaignType}`;
        }
        if (this.data.flagMetadataCampaignIsReference !== undefined) {
            customVariable['flag.metadata.isReference'] = `${this.data.flagMetadataCampaignIsReference}`;
        }
        if (this.data.hitContent !== undefined) {
            for (const key in this.data.hitContent) {
                const element = this.data.hitContent[key];
                customVariable[`hit.${key}`] = typeof element === 'string' ? element : JSON.stringify(element);
            }
        }
        if (this.data.batchTriggeredBy !== undefined) {
            customVariable.batchTriggeredBy = `${BatchTriggeredBy[this.data.batchTriggeredBy]}`;
        }
        if (this.data.accountSettings !== undefined) {
            for (const key in this.data.accountSettings) {
                const element = this.data.accountSettings[key];
                customVariable[`accountSettings.${key}`] = typeof element === 'string' ? element : JSON.stringify(element);
            }
        }
        if (this.data.eAIScore !== undefined) {
            customVariable['eAIScore.eai.eas'] = this.data.eAIScore.eai.eas;
        }
        if (this.data.isEAIScoreFromLocalCache !== undefined) {
            customVariable.isEAIScoreFromLocalCache = `${this.data.isEAIScoreFromLocalCache}`;
        }
        if (this.data.eAIDataTimestamp !== undefined) {
            customVariable.eAIDataTimestamp = `${this.data.eAIDataTimestamp}`;
        }
        apiKeys.cv = customVariable;
        return apiKeys;
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()));
    }
    getErrorMessage() {
        return ERROR_MESSAGE;
    }
}

;// ./src/hit/Troubleshooting.ts

class Troubleshooting extends Diagnostic {
    constructor(param) {
        super({
            ...param,
            type: 'TROUBLESHOOTING'
        });
    }
}

;// ./src/decision/DecisionManager.ts




class DecisionManager {
    _config;
    _panic = false;
    _httpClient;
    _statusChangedCallback;
    _troubleshooting;
    _lastBucketingTimestamp;
    _trackingManager;
    _flagshipInstanceId;
    get trackingManager() {
        return this._trackingManager;
    }
    set trackingManager(v) {
        this._trackingManager = v;
    }
    get flagshipInstanceId() {
        return this._flagshipInstanceId;
    }
    set flagshipInstanceId(v) {
        this._flagshipInstanceId = v;
    }
    get lastBucketingTimestamp() {
        return this._lastBucketingTimestamp;
    }
    get troubleshooting() {
        return this._troubleshooting;
    }
    set troubleshooting(v) {
        this._troubleshooting = v;
    }
    get config() {
        return this._config;
    }
    set panic(v) {
        this.updateFlagshipStatus(v ? FSSdkStatus.SDK_PANIC : FSSdkStatus.SDK_INITIALIZED);
        this._panic = v;
        if (v) {
            logDebug(this.config, FETCH_FLAGS_PANIC_MODE, PROCESS_FETCHING_FLAGS);
        }
    }
    statusChangedCallback(v) {
        this._statusChangedCallback = v;
    }
    constructor({ httpClient, config, trackingManager, flagshipInstanceId }) {
        this._config = config;
        this._httpClient = httpClient;
        this._trackingManager = trackingManager;
        this._flagshipInstanceId = flagshipInstanceId || '';
    }
    updateFlagshipStatus(v) {
        if (typeof this._statusChangedCallback === 'function' && this._statusChangedCallback) {
            this._statusChangedCallback(v);
        }
    }
    getModifications(campaigns) {
        const modifications = new Map();
        campaigns.forEach((campaign) => {
            const object = campaign.variation.modifications.value;
            for (const key in object) {
                const value = object[key];
                modifications.set(key, {
                    key,
                    campaignId: campaign.id,
                    campaignName: campaign.name || '',
                    variationGroupId: campaign.variationGroupId,
                    variationGroupName: campaign.variationGroupName || '',
                    variationId: campaign.variation.id,
                    variationName: campaign.variation.name || '',
                    isReference: !!campaign.variation.reference,
                    campaignType: campaign.type,
                    slug: campaign.slug,
                    value
                });
            }
        });
        return modifications;
    }
    isPanic() {
        return this._panic;
    }
    handleTroubleshootingError(params) {
        const { error, visitor, requestBody, headers, url, now } = params;
        const troubleshooting = new Troubleshooting({
            label: TroubleshootingLabel.GET_CAMPAIGNS_ROUTE_RESPONSE_ERROR,
            logLevel: LogLevel.ERROR,
            visitorId: visitor.visitorId,
            flagshipInstanceId: this.flagshipInstanceId,
            anonymousId: visitor.anonymousId,
            visitorSessionId: visitor.instanceId,
            traffic: 100,
            config: this.config,
            visitorContext: visitor.context,
            httpRequestBody: requestBody,
            httpRequestHeaders: headers,
            httpRequestMethod: 'POST',
            httpRequestUrl: url,
            httpResponseBody: error?.message,
            httpResponseHeaders: error?.headers,
            httpResponseCode: error?.statusCode,
            httpResponseTime: Date.now() - now
        });
        this.trackingManager?.addTroubleshootingHit(troubleshooting);
        const errorMessage = errorFormat(error.message || error, {
            url,
            headers,
            body: requestBody,
            duration: Date.now() - now
        });
        throw new Error(errorMessage);
    }
    async getDecisionApiCampaignsAsync(visitor) {
        const headers = {
            [HEADER_X_API_KEY]: `${this.config.apiKey}`,
            [HEADER_X_SDK_CLIENT]: SDK_INFO.name,
            [HEADER_X_SDK_VERSION]: SDK_INFO.version,
            [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON
        };
        const requestBody = {
            visitorId: visitor.visitorId,
            anonymousId: visitor.anonymousId,
            trigger_hit: false,
            context: visitor.context,
            visitor_consent: visitor.hasConsented
        };
        const url = `${this.config.decisionApiUrl || BASE_API_URL}${this.config.envId}${URL_CAMPAIGNS}?${EXPOSE_ALL_KEYS}=true&extras[]=accountSettings`;
        const now = Date.now();
        try {
            const response = await this._httpClient.postAsync(url, {
                headers,
                timeout: this.config.timeout,
                body: requestBody,
                nextFetchConfig: this.config.nextFetchConfig
            });
            this.panic = !!response?.body?.panic;
            let campaigns = null;
            if (response?.body?.campaigns) {
                campaigns = response.body.campaigns;
            }
            const troubleshooting = response?.body?.extras?.accountSettings?.troubleshooting;
            if (troubleshooting) {
                this.troubleshooting = {
                    startDate: new Date(troubleshooting.startDate),
                    endDate: new Date(troubleshooting.endDate),
                    timezone: troubleshooting.timezone,
                    traffic: troubleshooting.traffic
                };
            }
            return campaigns;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            this.handleTroubleshootingError({
                error,
                visitor,
                requestBody,
                headers,
                url,
                now
            });
        }
    }
}

;// ./src/decision/ApiManager.ts

class ApiManager extends DecisionManager {
    async getCampaignsAsync(visitor) {
        return this.getDecisionApiCampaignsAsync(visitor);
    }
}

;// ./src/enum/HitType.ts
var HitType;
(function (HitType) {
    /**
     * User has seen a URL
     *
     */
    HitType["PAGE_VIEW"] = "PAGEVIEW";
    /**
     * User has seen a URL
     *
     */
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    HitType["PAGE"] = "PAGEVIEW";
    /**
     * User has seen a screen.
     *
     */
    HitType["SCREEN_VIEW"] = "SCREENVIEW";
    /**
     * User has seen a screen.
     *
     */
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    HitType["SCREEN"] = "SCREENVIEW";
    /**
     * User has made a transaction.
     *
     */
    HitType["TRANSACTION"] = "TRANSACTION";
    /**
     * Item bought in a transaction.
     *
     */
    HitType["ITEM"] = "ITEM";
    /**
     * User has made a specific action.
     *
     */
    HitType["EVENT"] = "EVENT";
})(HitType || (HitType = {}));

;// ./src/hit/Segment.ts


const Segment_ERROR_MESSAGE = 'data property is required';
class Segment extends HitAbstract {
    _context;
    get context() {
        return this._context;
    }
    set context(v) {
        this._context = v;
    }
    constructor(param) {
        super({
            type: 'SEGMENT',
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId,
            qaMode: param.qaMode,
            isActionTrackingHit: param.isActionTrackingHit
        });
        this.context = param.context;
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) && this.context);
    }
    toApiKeys() {
        const apiKeys = super.toApiKeys();
        apiKeys[S_API_ITEM] = this.context;
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            context: this.context
        };
    }
    getErrorMessage() {
        return Segment_ERROR_MESSAGE;
    }
}

;// ./src/hit/EventCategory.ts
var EventCategory;
(function (EventCategory) {
    EventCategory["ACTION_TRACKING"] = "Action Tracking";
    EventCategory["USER_ENGAGEMENT"] = "User Engagement";
})(EventCategory || (EventCategory = {}));

;// ./src/hit/Event.ts





const Event_ERROR_MESSAGE = 'event category and event action are required';
const CATEGORY_ERROR = 'The category value must be either EventCategory::ACTION_TRACKING or EventCategory::ACTION_TRACKING';
const VALUE_FIELD_ERROR = 'value must be an integer and be >= 0';
class Event extends HitAbstract {
    _category;
    _action;
    _label;
    _value;
    get category() {
        return this._category;
    }
    /**
     * Specify Action Tracking or User Engagement.
     */
    set category(v) {
        if (!(Object.values(EventCategory).includes(v))) {
            logError(this.config, CATEGORY_ERROR, 'category');
            return;
        }
        this._category = v;
    }
    get action() {
        return this._action;
    }
    /**
     * Specify Event name that will also serve as the KPI
     * that you will have inside your reporting
     */
    set action(v) {
        if (!this.isNotEmptyString(v, 'action')) {
            return;
        }
        this._action = v;
    }
    get label() {
        return this._label;
    }
    /**
     * Specify additional description of event.
     */
    set label(v) {
        if (!this.isNotEmptyString(v, 'label')) {
            return;
        }
        this._label = v;
    }
    get value() {
        return this._value;
    }
    /**
     * Specify the monetary value associated with an event
     * (e.g. you earn 10 to 100 euros depending on the quality of lead generated).
     *
     * <br/> NOTE: this value must be non-negative.
     */
    set value(v) {
        if (!Number.isInteger(v) || v < 0) {
            logError(this.config, VALUE_FIELD_ERROR, 'value');
            return;
        }
        this._value = v;
    }
    constructor(param) {
        super({
            type: HitType.EVENT,
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId,
            qaMode: param.qaMode,
            isActionTrackingHit: param.isActionTrackingHit
        });
        const { category, action, label, value } = param;
        this.category = category;
        this.action = action;
        if (label) {
            this.label = label;
        }
        if (value) {
            this.value = value;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toApiKeys() {
        const apiKeys = super.toApiKeys();
        apiKeys[EVENT_CATEGORY_API_ITEM] = this.category;
        apiKeys[EVENT_ACTION_API_ITEM] = this.action;
        if (this.label) {
            apiKeys[EVENT_LABEL_API_ITEM] = this.label;
        }
        if (this.value) {
            apiKeys[EVENT_VALUE_API_ITEM] = this.value;
        }
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            category: this.category,
            action: this.action,
            label: this.label,
            value: this.value
        };
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) && this.category && this.action);
    }
    getErrorMessage() {
        return Event_ERROR_MESSAGE;
    }
}

;// ./src/hit/Screen.ts



const Screen_ERROR_MESSAGE = 'Screen name is required';
class Screen extends HitAbstract {
    _documentLocation;
    get documentLocation() {
        return this._documentLocation;
    }
    set documentLocation(v) {
        if (!this.isNotEmptyString(v, 'documentLocation')) {
            return;
        }
        this._documentLocation = v;
    }
    constructor(param) {
        super({
            type: HitType.SCREEN_VIEW,
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId,
            qaMode: param.qaMode,
            isActionTrackingHit: param.isActionTrackingHit
        });
        this.documentLocation = param.documentLocation;
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) && this.documentLocation);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toApiKeys() {
        const apiKeys = super.toApiKeys();
        apiKeys[DL_API_ITEM] = this.documentLocation;
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            documentLocation: this.documentLocation
        };
    }
    getErrorMessage() {
        return Screen_ERROR_MESSAGE;
    }
}

;// ./src/hit/ActivateBatch.ts

class ActivateBatch {
    _hits;
    _config;
    get hits() {
        return this._hits;
    }
    get config() {
        return this._config;
    }
    constructor(hits, config) {
        this._config = config;
        this._hits = hits;
    }
    toApiKeys() {
        return {
            [CUSTOMER_ENV_ID_API_ITEM]: `${this.config?.envId}`,
            [BATCH]: this.hits.map(x => {
                const apiKeys = x.toApiKeys();
                delete apiKeys[CUSTOMER_ENV_ID_API_ITEM];
                return apiKeys;
            })
        };
    }
}

;// ./src/hit/Activate.ts


const Activate_ERROR_MESSAGE = 'variationGroupId and variationId are required';
class Activate extends HitAbstract {
    _variationGroupId;
    _variationId;
    _flagKey;
    _flagValue;
    _flagDefaultValue;
    _flagMetadata;
    _visitorContext;
    constructor(param) {
        super({
            type: 'ACTIVATE',
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId,
            qaMode: param.qaMode
        });
        const { variationGroupId, variationId, flagKey, flagValue, flagDefaultValue, flagMetadata, visitorContext } = param;
        this.variationGroupId = variationGroupId;
        this.variationId = variationId;
        this.flagKey = flagKey;
        this.flagValue = flagValue;
        this.flagDefaultValue = flagDefaultValue;
        this.flagMetadata = flagMetadata;
        this.visitorContext = visitorContext;
    }
    get variationGroupId() {
        return this._variationGroupId;
    }
    set variationGroupId(v) {
        this._variationGroupId = v;
    }
    get variationId() {
        return this._variationId;
    }
    set variationId(v) {
        this._variationId = v;
    }
    get flagKey() {
        return this._flagKey;
    }
    set flagKey(v) {
        this._flagKey = v;
    }
    get flagValue() {
        return this._flagValue;
    }
    set flagValue(v) {
        this._flagValue = v;
    }
    get flagDefaultValue() {
        return this._flagDefaultValue;
    }
    set flagDefaultValue(v) {
        this._flagDefaultValue = v;
    }
    get flagMetadata() {
        return this._flagMetadata;
    }
    set flagMetadata(v) {
        this._flagMetadata = v;
    }
    get visitorContext() {
        return this._visitorContext;
    }
    set visitorContext(v) {
        this._visitorContext = v;
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) && this.variationGroupId && this.variationId);
    }
    toApiKeys() {
        const apiKeys = {
            [VISITOR_ID_API_ITEM]: this.anonymousId || this.visitorId,
            [VARIATION_ID_API_ITEM]: this.variationId,
            [VARIATION_GROUP_ID_API_ITEM_ACTIVATE]: this.variationGroupId,
            [CUSTOMER_ENV_ID_API_ACTIVATE]: this.config.envId,
            [ANONYMOUS_ID]: null,
            [QT_API_ITEM]: Date.now() - this.createdAt
        };
        if (this.visitorId && this.anonymousId) {
            apiKeys[VISITOR_ID_API_ITEM] = this.visitorId;
            apiKeys[ANONYMOUS_ID] = this.anonymousId;
        }
        if (this.qaMode) {
            apiKeys[QA_MODE_API_ITEM] = this.qaMode;
        }
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            variationGroupId: this.variationGroupId,
            variationId: this.variationId
        };
    }
    getErrorMessage() {
        return Activate_ERROR_MESSAGE;
    }
}

;// ./src/hit/Batch.ts


const Batch_BATCH = 'BATCH';
const Batch_ERROR_MESSAGE = 'Please check required fields';
class Batch extends HitAbstract {
    _hits;
    get hits() {
        return this._hits;
    }
    set hits(v) {
        this._hits = v;
    }
    constructor(params) {
        super({
            ...params,
            visitorId: '',
            anonymousId: '',
            type: Batch_BATCH
        });
        this.hits = params.hits;
    }
    isReady() {
        return !!(super.isReady() &&
            this.hits &&
            this.hits.length > 0 &&
            this.hits.every(hit => hit.isReady(false)));
    }
    toApiKeys() {
        const apiKeys = {
            [DS_API_ITEM]: this.ds,
            [CUSTOMER_ENV_ID_API_ITEM]: `${this.config?.envId}`,
            [T_API_ITEM]: this.type,
            [QT_API_ITEM]: Date.now() - this.createdAt
        };
        apiKeys.h = this.hits.map(hit => {
            const hitKeys = hit.toApiKeys();
            delete hitKeys[DS_API_ITEM];
            delete hitKeys[CUSTOMER_ENV_ID_API_ITEM];
            return hitKeys;
        });
        return apiKeys;
    }
    getErrorMessage() {
        return Batch_ERROR_MESSAGE;
    }
}

;// ./src/api/BatchingCachingStrategyAbstract.ts









class BatchingCachingStrategyAbstract {
    _config;
    _hitsPoolQueue;
    _activatePoolQueue;
    _httpClient;
    _troubleshootingQueue;
    _usageHitQueue;
    _flagshipInstanceId;
    _isUsageHitQueueSending;
    _isTroubleshootingQueueSending;
    _HitsToFsQa;
    _sendFsHitToQATimeoutId;
    _troubleshootingData;
    _initTroubleshootingHit;
    _hasInitTroubleshootingHitSent;
    _sharedActionTracking;
    get flagshipInstanceId() {
        return this._flagshipInstanceId;
    }
    get troubleshootingData() {
        return this._troubleshootingData;
    }
    set troubleshootingData(v) {
        this._troubleshootingData = v;
    }
    get config() {
        return this._config;
    }
    get initTroubleshootingHit() {
        return this._initTroubleshootingHit;
    }
    set initTroubleshootingHit(v) {
        this._initTroubleshootingHit = v;
    }
    constructor(param) {
        const { config, hitsPoolQueue, httpClient, activatePoolQueue, troubleshootingQueue, flagshipInstanceId, analyticHitQueue, initTroubleshootingHit: initTroubleshootingHi, sharedActionTracking } = param;
        this._HitsToFsQa = [];
        this._hasInitTroubleshootingHitSent = false;
        this._config = config;
        this._hitsPoolQueue = hitsPoolQueue;
        this._httpClient = httpClient;
        this._activatePoolQueue = activatePoolQueue;
        this._troubleshootingQueue = troubleshootingQueue;
        this._flagshipInstanceId = flagshipInstanceId;
        this._usageHitQueue = analyticHitQueue;
        this._isUsageHitQueueSending = false;
        this._isTroubleshootingQueueSending = false;
        this._initTroubleshootingHit = initTroubleshootingHi;
        this._sharedActionTracking = sharedActionTracking;
    }
    dispatchHitsToTag(hits) {
        if (false) {}
    }
    sendHitsToFsQa(hits) {
        if (false) {}
    }
    async addHit(hit) {
        const hitKey = `${hit.visitorId}:${uuidV4()}`;
        hit.key = hitKey;
        await this.addHitInPoolQueue(hit);
        if (hit.type === HitType.EVENT && hit.action === FS_CONSENT && hit.label === `${SDK_INFO.name}:false`) {
            await this.notConsent(hit.visitorId);
        }
        logDebugSprintf(this.config, TRACKING_MANAGER, HIT_ADDED_IN_QUEUE, hit.toApiKeys());
        if (this.config.trackingManagerConfig?.poolMaxSize &&
            this._hitsPoolQueue.size >= this.config.trackingManagerConfig.poolMaxSize &&
            this.config.decisionMode !== DecisionMode.BUCKETING_EDGE) {
            this.sendBatch();
        }
    }
    async activateFlag(paramHit) {
        const hit = new Activate(paramHit);
        hit.config = this.config;
        const hitKey = `${hit.visitorId}:${uuidV4()}`;
        hit.key = hitKey;
        if (this.config.decisionMode === DecisionMode.BUCKETING_EDGE || this.config.batchActivateHits) {
            await this.activateFlagEdgeMode(hit);
            logDebug(this.config, sprintf(ACTIVATE_ADDED_IN_QUEUE, JSON.stringify(hit.toApiKeys())), ADD_ACTIVATE);
            return;
        }
        let activateHitsPool = [];
        if (this._activatePoolQueue.size) {
            activateHitsPool = Array.from(this._activatePoolQueue.values());
        }
        this._activatePoolQueue.clear();
        await this.sendActivate({
            activateHitsPool,
            currentActivate: hit,
            batchTriggeredBy: BatchTriggeredBy.ActivateLength
        });
    }
    async activateFlagEdgeMode(hit) {
        this._activatePoolQueue.set(hit.key, hit);
        await this.cacheHit(new Map([[hit.key, hit]]));
    }
    onVisitorExposed(activate) {
        const onVisitorExposed = this.config.onVisitorExposed;
        if (typeof onVisitorExposed !== 'function') {
            return;
        }
        const fromFlag = {
            key: activate.flagKey,
            value: activate.flagValue,
            defaultValue: activate.flagDefaultValue,
            metadata: activate.flagMetadata
        };
        const exposedVisitor = {
            id: activate.visitorId,
            anonymousId: activate.anonymousId,
            context: activate.visitorContext
        };
        onVisitorExposed({
            exposedVisitor,
            fromFlag
        });
    }
    async sendBatch(batchTriggeredBy = BatchTriggeredBy.BatchLength) {
        if (this._activatePoolQueue.size) {
            const activateHits = Array.from(this._activatePoolQueue.values());
            this._activatePoolQueue.clear();
            await this.sendActivate({
                activateHitsPool: activateHits,
                batchTriggeredBy
            });
        }
        const batch = new Batch({
            hits: [],
            ds: SDK_APP
        });
        batch.config = this.config;
        const hitKeysToRemove = [];
        for (const [key, item] of this._hitsPoolQueue) {
            if ((Date.now() - item.createdAt) >= DEFAULT_HIT_CACHE_TIME_MS) {
                hitKeysToRemove.push(key);
                continue;
            }
            const batchSize = JSON.stringify(batch).length;
            if (batchSize > BATCH_MAX_SIZE) {
                break;
            }
            batch.hits.push(item);
            hitKeysToRemove.push(key);
        }
        hitKeysToRemove.forEach(key => {
            this._hitsPoolQueue.delete(key);
        });
        if (!batch.hits.length) {
            return;
        }
        const headers = { [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON };
        const requestBody = batch.toApiKeys();
        const now = Date.now();
        try {
            await this._httpClient.postAsync(HIT_EVENT_URL, {
                headers,
                body: requestBody,
                timeout: this.config.timeout,
                nextFetchConfig: this.config.nextFetchConfig
            });
            logDebugSprintf(this.config, TRACKING_MANAGER, HIT_SENT_SUCCESS, BATCH_HIT, {
                url: HIT_EVENT_URL,
                body: requestBody,
                headers,
                nextFetchConfig: this.config.nextFetchConfig,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            await this.flushHits(hitKeysToRemove);
            this.sendHitsToFsQa(batch.hits);
            this.dispatchHitsToTag(batch.hits);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            batch.hits.forEach((hit) => {
                this._hitsPoolQueue.set(hit.key, hit);
            });
            logErrorSprintf(this.config, TRACKING_MANAGER, TRACKING_MANAGER_ERROR, BATCH_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: HIT_EVENT_URL,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const monitoringHttpResponse = new Troubleshooting({
                label: TroubleshootingLabel.SEND_BATCH_HIT_ROUTE_RESPONSE_ERROR,
                logLevel: LogLevel.ERROR,
                visitorId: `${this._flagshipInstanceId}`,
                flagshipInstanceId: this._flagshipInstanceId,
                traffic: 0,
                config: this.config,
                httpRequestBody: batch.hits,
                httpRequestHeaders: headers,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseMethod: 'POST',
                httpResponseUrl: HIT_EVENT_URL,
                httpResponseCode: error?.statusCode,
                httpResponseTime: Date.now() - now,
                batchTriggeredBy
            });
            this.sendTroubleshootingHit(monitoringHttpResponse);
        }
    }
    async notConsent(visitorId) {
        const hitKeys = Array.from(this._hitsPoolQueue).filter(([, item]) => {
            return (item?.type !== HitType.EVENT || item?.action !== FS_CONSENT) && (item.visitorId === visitorId || item.anonymousId === visitorId);
        });
        const activateKeys = Array.from(this._activatePoolQueue).filter(([, item]) => {
            return item.visitorId === visitorId || item.anonymousId === visitorId;
        });
        const keysToFlush = [];
        hitKeys.forEach(([key]) => {
            this._hitsPoolQueue.delete(key);
            keysToFlush.push(key);
        });
        activateKeys.forEach(([key]) => {
            this._activatePoolQueue.delete(key);
            keysToFlush.push(key);
        });
        if (!keysToFlush.length) {
            return;
        }
        await this.flushHits(keysToFlush);
    }
    async cacheHit(hits) {
        try {
            const hitCacheImplementation = this.config.hitCacheImplementation;
            if (this.config.disableCache || !hitCacheImplementation || typeof hitCacheImplementation.cacheHit !== 'function') {
                return;
            }
            const data = {};
            hits.forEach((item, key) => {
                const hitData = {
                    version: HIT_CACHE_VERSION,
                    data: {
                        visitorId: item.visitorId,
                        anonymousId: item.anonymousId,
                        type: item.type,
                        content: item.toObject(),
                        time: Date.now()
                    }
                };
                data[key] = hitData;
            });
            await hitCacheImplementation.cacheHit(data);
            logDebugSprintf(this.config, PROCESS_CACHE_HIT, HIT_CACHE_SAVED, data);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, HIT_CACHE_ERROR, 'cacheHit', error.message || error);
        }
    }
    async flushHits(hitKeys) {
        try {
            const hitCacheImplementation = this.config.hitCacheImplementation;
            if (this.config.disableCache || !hitCacheImplementation || typeof hitCacheImplementation.flushHits !== 'function') {
                return;
            }
            await hitCacheImplementation.flushHits(hitKeys);
            logDebugSprintf(this.config, PROCESS_CACHE, HIT_DATA_FLUSHED, hitKeys);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, HIT_CACHE_ERROR, 'flushHits', error.message || error);
        }
    }
    async flushAllHits() {
        try {
            const hitCacheImplementation = this.config.hitCacheImplementation;
            if (this.config.disableCache || !hitCacheImplementation || typeof hitCacheImplementation.flushAllHits !== 'function') {
                return;
            }
            await hitCacheImplementation.flushAllHits();
            logDebug(this.config, ALL_HITS_FLUSHED, PROCESS_FLUSH_HIT);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, HIT_CACHE_ERROR, 'flushAllHits', error.message || error);
        }
    }
    // #region Troubleshooting
    isTroubleshootingActivated() {
        if (!this.troubleshootingData) {
            return false;
        }
        const now = new Date();
        const isStarted = now >= this.troubleshootingData.startDate;
        if (!isStarted) {
            return false;
        }
        const isFinished = now > this.troubleshootingData.endDate;
        if (isFinished) {
            this._hasInitTroubleshootingHitSent = false;
            return false;
        }
        return true;
    }
    async addTroubleshootingHit(hit) {
        if (!hit.key) {
            const hitKey = `${hit.visitorId}:${uuidV4()}`;
            hit.key = hitKey;
        }
        this._troubleshootingQueue.set(hit.key, hit);
        logDebug(this.config, sprintf(TROUBLESHOOTING_HIT_ADDED_IN_QUEUE, JSON.stringify(hit.toApiKeys())), ADD_TROUBLESHOOTING_HIT);
    }
    async sendTroubleshootingHit(hit) {
        if (!this.isTroubleshootingActivated() || hit.traffic === undefined || this.troubleshootingData.traffic < hit.traffic) {
            return;
        }
        const requestBody = hit.toApiKeys();
        const now = Date.now();
        try {
            await this._httpClient.postAsync(TROUBLESHOOTING_HIT_URL, { body: requestBody });
            logDebug(this.config, sprintf(TROUBLESHOOTING_SENT_SUCCESS, JSON.stringify({
                ...requestBody,
                duration: Date.now() - now
            })), SEND_TROUBLESHOOTING);
            if (hit.key) {
                this._troubleshootingQueue.delete(hit.key);
                await this.flushHits([hit.key]);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            if (this.isTroubleshootingActivated()) {
                await this.addTroubleshootingHit(hit);
            }
            logError(this.config, errorFormat(error.message || error, {
                url: TROUBLESHOOTING_HIT_URL,
                headers: {},
                body: requestBody,
                duration: Date.now() - now
            }), SEND_BATCH);
        }
    }
    async sendInitTroubleshootingHit() {
        if (!this.isTroubleshootingActivated() || !this._initTroubleshootingHit || this._hasInitTroubleshootingHitSent) {
            return;
        }
        await this.sendTroubleshootingHit(this._initTroubleshootingHit);
        this._hasInitTroubleshootingHitSent = true;
    }
    async sendTroubleshootingQueue() {
        await this.sendInitTroubleshootingHit();
        if (!this.isTroubleshootingActivated() || this._isTroubleshootingQueueSending || this._troubleshootingQueue.size === 0) {
            return;
        }
        this._isTroubleshootingQueueSending = true;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, item] of Array.from(this._troubleshootingQueue)) {
            await this.sendTroubleshootingHit(item);
        }
        this._isTroubleshootingQueueSending = false;
    }
    // #endregion
    // #region Analytic hit
    async addUsageHit(hit) {
        if (!hit.key) {
            const hitKey = `${hit.visitorId}:${uuidV4()}`;
            hit.key = hitKey;
        }
        this._usageHitQueue.set(hit.key, hit);
        logDebug(this.config, sprintf(ANALYTICS_HIT_ADDED_IN_QUEUE, JSON.stringify(hit.toApiKeys())), ADD_USAGE_HIT);
    }
    async sendUsageHit(hit) {
        const requestBody = hit.toApiKeys();
        const now = Date.now();
        try {
            await this._httpClient.postAsync(USAGE_HIT_URL, { body: requestBody });
            logDebug(this.config, sprintf(ANALYTICS_HIT_SENT_SUCCESS, JSON.stringify({
                ...requestBody,
                duration: Date.now() - now
            })), SEND_USAGE_HIT);
            if (hit.key) {
                this._usageHitQueue.delete(hit.key);
                await this.flushHits([hit.key]);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            await this.addUsageHit(hit);
            logError(this.config, errorFormat(error.message || error, {
                url: USAGE_HIT_URL,
                headers: {},
                body: requestBody,
                duration: Date.now() - now
            }), SEND_BATCH);
        }
    }
    async sendUsageHitQueue() {
        if (this._isUsageHitQueueSending || this._usageHitQueue.size === 0) {
            return;
        }
        this._isUsageHitQueueSending = true;
        for (const [, item] of Array.from(this._usageHitQueue)) {
            await this.sendUsageHit(item);
        }
        this._isUsageHitQueueSending = false;
    }
}

;// ./src/api/BatchingContinuousCachingStrategy.ts








class BatchingContinuousCachingStrategy extends BatchingCachingStrategyAbstract {
    async addHitInPoolQueue(hit) {
        this._hitsPoolQueue.set(hit.key, hit);
        await this.cacheHit(new Map([[hit.key, hit]]));
    }
    async sendActivateHitBatch(activateBatch, batchTriggeredBy, currentActivate) {
        const headers = {
            [HEADER_X_API_KEY]: this.config.apiKey,
            [HEADER_X_SDK_CLIENT]: SDK_INFO.name,
            [HEADER_X_SDK_VERSION]: SDK_INFO.version,
            [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON
        };
        if (currentActivate) {
            activateBatch.hits.push(currentActivate);
        }
        const requestBody = activateBatch.toApiKeys();
        const url = BASE_API_URL + URL_ACTIVATE_MODIFICATION;
        const now = Date.now();
        try {
            await this._httpClient.postAsync(url, {
                headers,
                body: requestBody,
                timeout: this.config.timeout,
                nextFetchConfig: this.config.nextFetchConfig
            });
            logDebugSprintf(this.config, TRACKING_MANAGER, HIT_SENT_SUCCESS, ACTIVATE_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const hitKeysToRemove = activateBatch.hits.filter(item => item.key !== currentActivate?.key).map(item => item.key);
            activateBatch.hits.forEach(item => {
                this.onVisitorExposed(item);
            });
            if (hitKeysToRemove.length) {
                await this.flushHits(hitKeysToRemove);
            }
            this.sendHitsToFsQa(activateBatch.hits);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            activateBatch.hits.forEach(item => {
                this._activatePoolQueue.set(item.key, item);
            });
            if (currentActivate) {
                await this.cacheHit(new Map([[currentActivate.key, currentActivate]]));
            }
            logErrorSprintf(this.config, TRACKING_MANAGER, TRACKING_MANAGER_ERROR, ACTIVATE_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const monitoringHttpResponse = new Troubleshooting({
                label: TroubleshootingLabel.SEND_ACTIVATE_HIT_ROUTE_ERROR,
                logLevel: LogLevel.ERROR,
                visitorId: `${this._flagshipInstanceId}`,
                traffic: 0,
                config: this.config,
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                httpResponseTime: Date.now() - now,
                batchTriggeredBy
            });
            this.sendTroubleshootingHit(monitoringHttpResponse);
        }
    }
    async sendActivate({ activateHitsPool, currentActivate, batchTriggeredBy }) {
        const filteredItems = Array.from(activateHitsPool.filter(item => (Date.now() - item.createdAt) < DEFAULT_HIT_CACHE_TIME_MS));
        if (!filteredItems.length && currentActivate) {
            const batch = new ActivateBatch([], this.config);
            await this.sendActivateHitBatch(batch, batchTriggeredBy, currentActivate);
            return;
        }
        for (let i = 0; i < filteredItems.length; i += MAX_ACTIVATE_HIT_PER_BATCH) {
            const batch = new ActivateBatch(filteredItems.slice(i, i + MAX_ACTIVATE_HIT_PER_BATCH), this.config);
            this.sendActivateHitBatch(batch, batchTriggeredBy, i === 0 ? currentActivate : undefined);
        }
    }
}

;// ./src/api/BatchingPeriodicCachingStrategy.ts








class BatchingPeriodicCachingStrategy extends BatchingCachingStrategyAbstract {
    async addHitInPoolQueue(hit) {
        this._hitsPoolQueue.set(hit.key, hit);
    }
    async sendActivate({ activateHitsPool, currentActivate, batchTriggeredBy }) {
        const headers = {
            [HEADER_X_API_KEY]: this.config.apiKey,
            [HEADER_X_SDK_CLIENT]: SDK_INFO.name,
            [HEADER_X_SDK_VERSION]: SDK_INFO.version,
            [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON
        };
        const activateBatch = new ActivateBatch(Array.from(activateHitsPool.filter(item => (Date.now() - item.createdAt) < DEFAULT_HIT_CACHE_TIME_MS)), this.config);
        if (currentActivate) {
            activateBatch.hits.push(currentActivate);
        }
        const requestBody = activateBatch.toApiKeys();
        const url = BASE_API_URL + URL_ACTIVATE_MODIFICATION;
        const now = Date.now();
        try {
            await this._httpClient.postAsync(url, {
                headers,
                body: requestBody,
                timeout: this.config.timeout,
                nextFetchConfig: this.config.nextFetchConfig
            });
            logDebugSprintf(this.config, TRACKING_MANAGER, HIT_SENT_SUCCESS, ACTIVATE_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            activateBatch.hits.forEach(item => {
                this.onVisitorExposed(item);
            });
            this.sendHitsToFsQa(activateBatch.hits);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            activateBatch.hits.forEach(item => {
                this._activatePoolQueue.set(item.key, item);
            });
            logErrorSprintf(this.config, TRACKING_MANAGER, TRACKING_MANAGER_ERROR, ACTIVATE_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const monitoringHttpResponse = new Troubleshooting({
                label: TroubleshootingLabel.SEND_ACTIVATE_HIT_ROUTE_ERROR,
                logLevel: LogLevel.ERROR,
                visitorId: `${this._flagshipInstanceId}`,
                traffic: 0,
                config: this.config,
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                httpResponseTime: Date.now() - now,
                batchTriggeredBy
            });
            this.sendTroubleshootingHit(monitoringHttpResponse);
        }
    }
    async sendBatch(batchTriggeredBy = BatchTriggeredBy.BatchLength) {
        let hasActivateHit = false;
        if (this._activatePoolQueue.size) {
            const activateHits = Array.from(this._activatePoolQueue.values());
            this._activatePoolQueue.clear();
            await this.sendActivate({
                activateHitsPool: activateHits,
                batchTriggeredBy
            });
            hasActivateHit = true;
        }
        const headers = { [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON };
        const batch = new Batch({ hits: [] });
        batch.config = this.config;
        let batchSize = 0;
        const hitKeysToRemove = [];
        for (const [key, item] of this._hitsPoolQueue) {
            if ((Date.now() - item.createdAt) >= DEFAULT_HIT_CACHE_TIME_MS) {
                hitKeysToRemove.push(key);
                continue;
            }
            batchSize = JSON.stringify(batch).length;
            if (batchSize > BATCH_MAX_SIZE) {
                break;
            }
            batch.hits.push(item);
            hitKeysToRemove.push(key);
        }
        hitKeysToRemove.forEach(key => {
            this._hitsPoolQueue.delete(key);
        });
        if (!batch.hits.length) {
            if (hasActivateHit) {
                await this.cacheHit(this._activatePoolQueue);
            }
            return;
        }
        const requestBody = batch.toApiKeys();
        const now = Date.now();
        try {
            await this._httpClient.postAsync(HIT_EVENT_URL, {
                headers,
                body: requestBody,
                timeout: this.config.timeout,
                nextFetchConfig: this.config.nextFetchConfig
            });
            logDebugSprintf(this.config, TRACKING_MANAGER, HIT_SENT_SUCCESS, BATCH_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: HIT_EVENT_URL,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            this.sendHitsToFsQa(batch.hits);
            this.dispatchHitsToTag(batch.hits);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            batch.hits.forEach((hit) => {
                this._hitsPoolQueue.set(hit.key, hit);
            });
            logErrorSprintf(this.config, TRACKING_MANAGER, TRACKING_MANAGER_ERROR, BATCH_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: HIT_EVENT_URL,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const monitoringHttpResponse = new Troubleshooting({
                label: TroubleshootingLabel.SEND_BATCH_HIT_ROUTE_RESPONSE_ERROR,
                logLevel: LogLevel.ERROR,
                visitorId: `${this._flagshipInstanceId}`,
                traffic: 0,
                config: this.config,
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseMethod: 'POST',
                httpResponseUrl: HIT_EVENT_URL,
                httpResponseCode: error?.statusCode,
                httpResponseTime: Date.now() - now
            });
            this.addTroubleshootingHit(monitoringHttpResponse);
        }
        const mergedQueue = new Map([...this._hitsPoolQueue, ...this._activatePoolQueue]);
        await this.flushAllHits();
        await this.cacheHit(mergedQueue);
    }
}

;// ./src/api/NoBatchingContinuousCachingStrategy.ts







class NoBatchingContinuousCachingStrategy extends BatchingCachingStrategyAbstract {
    cacheHitKeys;
    constructor(param) {
        super(param);
        this.cacheHitKeys = {};
    }
    async activateFlag(hit) {
        const hitKey = `${hit.visitorId}:${uuidV4()}`;
        hit.key = hitKey;
        await this.sendActivate({
            activateHitsPool: [],
            currentActivate: hit,
            batchTriggeredBy: BatchTriggeredBy.ActivateLength
        });
    }
    async addHit(hit) {
        const hitKey = `${hit.visitorId}:${uuidV4()}`;
        hit.key = hitKey;
        if (hit.type === HitType.EVENT && hit.action === FS_CONSENT && hit.label === `${SDK_INFO.name}:false`) {
            await this.notConsent(hit.visitorId);
        }
        await this.sendHit(hit);
    }
    addHitInPoolQueue(_hit) {
        return Promise.resolve();
    }
    async sendHit(hit) {
        const headers = { [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON };
        const requestBody = hit.toApiKeys();
        const now = Date.now();
        try {
            await this._httpClient.postAsync(HIT_EVENT_URL, {
                headers,
                body: requestBody,
                timeout: this.config.timeout,
                nextFetchConfig: this.config.nextFetchConfig
            });
            logDebugSprintf(this.config, TRACKING_MANAGER, HIT_SENT_SUCCESS, DIRECT_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: HIT_EVENT_URL,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[BatchTriggeredBy.DirectHit]
            });
            this.sendHitsToFsQa([hit]);
            this.dispatchHitsToTag([hit]);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            if (hit.type !== HitType.EVENT || hit.action !== FS_CONSENT) {
                this.cacheHitKeys[hit.key] = hit.visitorId;
            }
            await this.cacheHit(new Map().set(hit.key, hit));
            logErrorSprintf(this.config, TRACKING_MANAGER, TRACKING_MANAGER_ERROR, DIRECT_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: HIT_EVENT_URL,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[BatchTriggeredBy.DirectHit]
            });
            const monitoringHttpResponse = new Troubleshooting({
                label: TroubleshootingLabel.SEND_HIT_ROUTE_ERROR,
                logLevel: LogLevel.ERROR,
                visitorId: `${this._flagshipInstanceId}`,
                traffic: 0,
                config: this.config,
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: HIT_EVENT_URL,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                httpResponseTime: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy.DirectHit
            });
            this.sendTroubleshootingHit(monitoringHttpResponse);
        }
    }
    async notConsent(visitorId) {
        const cacheHitKeysEntries = Object.entries(this.cacheHitKeys).filter(([_, value]) => value === visitorId);
        const keys = [];
        for (const [key] of cacheHitKeysEntries) {
            keys.push(key);
        }
        const hitsKeys = Array.from(this._hitsPoolQueue).filter(([_, item]) => {
            return (item?.type !== HitType.EVENT || item?.action !== FS_CONSENT) && (item.visitorId === visitorId || item.anonymousId === visitorId);
        });
        const activateKeys = Array.from(this._activatePoolQueue).filter(([_, item]) => {
            return item.visitorId === visitorId || item.anonymousId === visitorId;
        });
        const keysToFlush = [];
        hitsKeys.forEach(([key]) => {
            this._hitsPoolQueue.delete(key);
            keysToFlush.push(key);
        });
        activateKeys.forEach(([key]) => {
            this._activatePoolQueue.delete(key);
            keysToFlush.push(key);
        });
        const mergedKeys = [...keys, ...keysToFlush];
        if (!mergedKeys.length) {
            return;
        }
        await this.flushHits(mergedKeys);
        this.cacheHitKeys = {};
    }
    async sendActivate({ activateHitsPool, currentActivate, batchTriggeredBy }) {
        const headers = {
            [HEADER_X_API_KEY]: this.config.apiKey,
            [HEADER_X_SDK_CLIENT]: SDK_INFO.name,
            [HEADER_X_SDK_VERSION]: SDK_INFO.version,
            [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON
        };
        const activateBatch = new ActivateBatch(Array.from(activateHitsPool.filter(item => (Date.now() - item.createdAt) < DEFAULT_HIT_CACHE_TIME_MS)), this.config);
        if (currentActivate) {
            activateBatch.hits.push(currentActivate);
        }
        const requestBody = activateBatch.toApiKeys();
        const url = BASE_API_URL + URL_ACTIVATE_MODIFICATION;
        const now = Date.now();
        try {
            await this._httpClient.postAsync(url, {
                headers,
                body: requestBody,
                timeout: this.config.timeout,
                nextFetchConfig: this.config.nextFetchConfig
            });
            logDebugSprintf(this.config, TRACKING_MANAGER, HIT_SENT_SUCCESS, ACTIVATE_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const hitKeysToRemove = activateHitsPool.map(item => item.key);
            activateBatch.hits.forEach(item => {
                this.onVisitorExposed(item);
            });
            if (hitKeysToRemove.length) {
                await this.flushHits(hitKeysToRemove);
            }
            this.sendHitsToFsQa(activateBatch.hits);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            activateBatch.hits.forEach((item) => {
                this.cacheHitKeys[item.key] = item.visitorId;
            });
            if (currentActivate) {
                await this.cacheHit(new Map([[currentActivate.key, currentActivate]]));
            }
            logErrorSprintf(this.config, TRACKING_MANAGER, TRACKING_MANAGER_ERROR, ACTIVATE_HIT, {
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseCode: error?.statusCode,
                duration: Date.now() - now,
                batchTriggeredBy: BatchTriggeredBy[batchTriggeredBy]
            });
            const monitoringHttpResponse = new Troubleshooting({
                label: TroubleshootingLabel.SEND_ACTIVATE_HIT_ROUTE_ERROR,
                logLevel: LogLevel.ERROR,
                visitorId: `${this._flagshipInstanceId}`,
                traffic: 0,
                config: this.config,
                httpRequestBody: requestBody,
                httpRequestHeaders: headers,
                httpRequestMethod: 'POST',
                httpRequestUrl: url,
                httpResponseBody: error?.message,
                httpResponseHeaders: error?.headers,
                httpResponseMethod: 'POST',
                httpResponseUrl: url,
                httpResponseCode: error?.statusCode,
                httpResponseTime: Date.now() - now,
                batchTriggeredBy
            });
            this.sendTroubleshootingHit(monitoringHttpResponse);
        }
    }
}

;// ./src/hit/Item.ts



const Item_ERROR_MESSAGE = 'Transaction Id, Item name and item code are required';
class Item extends HitAbstract {
    _transactionId;
    _productName;
    _productSku;
    _itemPrice;
    _itemQuantity;
    _itemCategory;
    get transactionId() {
        return this._transactionId;
    }
    /**
     * Specify transaction unique identifier.
     */
    set transactionId(v) {
        if (!this.isNotEmptyString(v, 'transactionId')) {
            return;
        }
        this._transactionId = v;
    }
    get productName() {
        return this._productName;
    }
    /**
     * Specify name of the item product.
     */
    set productName(v) {
        if (!this.isNotEmptyString(v, 'productName')) {
            return;
        }
        this._productName = v;
    }
    get productSku() {
        return this._productSku;
    }
    /**
     * Specify the SKU or item code.
     */
    set productSku(v) {
        if (!this.isNotEmptyString(v, 'productSku')) {
            return;
        }
        this._productSku = v;
    }
    get itemPrice() {
        return this._itemPrice;
    }
    /**
     * Specify the price for a single item
     */
    set itemPrice(v) {
        if (!this.isNumeric(v, 'itemPrice')) {
            return;
        }
        this._itemPrice = v;
    }
    get itemQuantity() {
        return this._itemQuantity;
    }
    /**
     * Specify the number of items purchased.
     */
    set itemQuantity(v) {
        if (!this.isInteger(v, 'itemQuantity')) {
            return;
        }
        this._itemQuantity = Math.trunc(v);
    }
    get itemCategory() {
        return this._itemCategory;
    }
    /**
     * Specify the category that the item belongs to
     */
    set itemCategory(v) {
        if (!this.isNotEmptyString(v, 'itemCategory')) {
            return;
        }
        this._itemCategory = v;
    }
    /**
     *Item constructor.
     * @param transactionId : Transaction unique identifier.
     * @param productName : Name of the item product.
     * @param productSku : The SKU or item code.
     */
    constructor(param) {
        super({
            type: HitType.ITEM,
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId,
            qaMode: param.qaMode,
            isActionTrackingHit: param.isActionTrackingHit
        });
        const { transactionId, productName, productSku, itemCategory, itemPrice, itemQuantity } = param;
        this.transactionId = transactionId;
        this.productName = productName;
        this.productSku = productSku;
        if (itemCategory) {
            this.itemCategory = itemCategory;
        }
        if (itemPrice) {
            this.itemPrice = itemPrice;
        }
        if (itemQuantity) {
            this.itemQuantity = itemQuantity;
        }
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) &&
            this.transactionId &&
            this.productName &&
            this.productSku);
    }
    toApiKeys() {
        const apiKeys = super.toApiKeys();
        apiKeys[TID_API_ITEM] = this.transactionId;
        apiKeys[IN_API_ITEM] = this.productName;
        apiKeys[IC_API_ITEM] = this.productSku;
        if (this.itemPrice) {
            apiKeys[IP_API_ITEM] = this.itemPrice;
        }
        if (this.itemQuantity) {
            apiKeys[IQ_API_ITEM] = this.itemQuantity;
        }
        if (this.itemCategory) {
            apiKeys[IV_API_ITEM] = this.itemCategory;
        }
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            transactionId: this.transactionId,
            productName: this.productName,
            productSku: this.productSku,
            itemPrice: this.itemPrice,
            itemQuantity: this.itemQuantity,
            itemCategory: this.itemCategory
        };
    }
    getErrorMessage() {
        return Item_ERROR_MESSAGE;
    }
}

;// ./src/hit/Page.ts



const Page_ERROR_MESSAGE = 'documentLocation url is required';
class Page extends HitAbstract {
    _documentLocation;
    get documentLocation() {
        return this._documentLocation;
    }
    set documentLocation(v) {
        if (!this.isNotEmptyString(v, 'documentLocation')) {
            return;
        }
        this._documentLocation = v;
    }
    constructor(page) {
        super({
            type: HitType.PAGE_VIEW,
            userIp: page.userIp,
            screenResolution: page.screenResolution,
            locale: page.locale,
            sessionNumber: page.sessionNumber,
            visitorId: page.visitorId,
            anonymousId: page.anonymousId,
            qaMode: page.qaMode,
            isActionTrackingHit: page.isActionTrackingHit
        });
        this.documentLocation = page.documentLocation;
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) && this.documentLocation);
    }
    toApiKeys() {
        const apiKeys = super.toApiKeys();
        apiKeys[DL_API_ITEM] = this.documentLocation;
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            documentLocation: this.documentLocation
        };
    }
    getErrorMessage() {
        return Page_ERROR_MESSAGE;
    }
}

;// ./src/hit/Transaction.ts
/* eslint-disable @typescript-eslint/no-explicit-any */




const CURRENCY_ERROR = '{0} must be a string and have exactly 3 letters';
const Transaction_ERROR_MESSAGE = 'Transaction Id and Transaction affiliation are required';
class Transaction extends HitAbstract {
    _transactionId;
    _affiliation;
    _taxes;
    _currency;
    _couponCode;
    _itemCount;
    _shippingMethod;
    _paymentMethod;
    _totalRevenue;
    _shippingCosts;
    get transactionId() {
        return this._transactionId;
    }
    set transactionId(v) {
        if (!this.isNotEmptyString(v, 'transactionId')) {
            return;
        }
        this._transactionId = v;
    }
    get affiliation() {
        return this._affiliation;
    }
    set affiliation(v) {
        if (!this.isNotEmptyString(v, 'affiliation')) {
            return;
        }
        this._affiliation = v;
    }
    get taxes() {
        return this._taxes;
    }
    set taxes(v) {
        if (!this.isNumeric(v, 'taxes')) {
            return;
        }
        this._taxes = v;
    }
    get currency() {
        return this._currency;
    }
    set currency(v) {
        if (!v || typeof v !== 'string' || v.length !== 3) {
            logError(this.config, sprintf(CURRENCY_ERROR, 'currency'), 'currency');
            return;
        }
        this._currency = v;
    }
    get couponCode() {
        return this._couponCode;
    }
    set couponCode(v) {
        if (!this.isNotEmptyString(v, 'couponCode')) {
            return;
        }
        this._couponCode = v;
    }
    get itemCount() {
        return this._itemCount;
    }
    set itemCount(v) {
        if (!this.isInteger(v, 'itemCount')) {
            return;
        }
        this._itemCount = Math.trunc(v);
    }
    get shippingMethod() {
        return this._shippingMethod;
    }
    set shippingMethod(v) {
        if (!this.isNotEmptyString(v, 'shippingMethod')) {
            return;
        }
        this._shippingMethod = v;
    }
    get paymentMethod() {
        return this._paymentMethod;
    }
    set paymentMethod(v) {
        if (!this.isNotEmptyString(v, 'paymentMethod')) {
            return;
        }
        this._paymentMethod = v;
    }
    get totalRevenue() {
        return this._totalRevenue;
    }
    set totalRevenue(v) {
        if (!this.isNumeric(v, 'totalRevenue')) {
            return;
        }
        this._totalRevenue = v;
    }
    get shippingCosts() {
        return this._shippingCosts;
    }
    set shippingCosts(v) {
        if (!this.isNumeric(v, 'shippingCosts')) {
            return;
        }
        this._shippingCosts = v;
    }
    constructor(param) {
        super({
            type: HitType.TRANSACTION,
            userIp: param.userIp,
            screenResolution: param.screenResolution,
            locale: param.locale,
            sessionNumber: param.sessionNumber,
            visitorId: param.visitorId,
            anonymousId: param.anonymousId,
            qaMode: param.qaMode,
            isActionTrackingHit: param.isActionTrackingHit
        });
        const { transactionId, affiliation, taxes, currency, couponCode, itemCount, shippingMethod, paymentMethod, totalRevenue, shippingCosts } = param;
        this.transactionId = transactionId;
        this.affiliation = affiliation;
        if (taxes) {
            this.taxes = taxes;
        }
        if (currency) {
            this.currency = currency;
        }
        if (couponCode) {
            this.couponCode = couponCode;
        }
        if (itemCount) {
            this.itemCount = itemCount;
        }
        if (shippingMethod) {
            this.shippingMethod = shippingMethod;
        }
        if (paymentMethod) {
            this.paymentMethod = paymentMethod;
        }
        if (totalRevenue) {
            this.totalRevenue = totalRevenue;
        }
        if (shippingCosts) {
            this.shippingCosts = shippingCosts;
        }
    }
    isReady(checkParent = true) {
        return !!((!checkParent || super.isReady()) && this.transactionId && this.affiliation);
    }
    toApiKeys() {
        const apiKeys = super.toApiKeys();
        apiKeys[TID_API_ITEM] = this.transactionId;
        apiKeys[TA_API_ITEM] = this.affiliation;
        if (this.taxes) {
            apiKeys[TT_API_ITEM] = this.taxes;
        }
        if (this.currency) {
            apiKeys[TC_API_ITEM] = this.currency;
        }
        if (this.couponCode) {
            apiKeys[TCC_API_ITEM] = this.couponCode;
        }
        if (this.itemCount) {
            apiKeys[ICN_API_ITEM] = this.itemCount;
        }
        if (this.shippingMethod) {
            apiKeys[SM_API_ITEM] = this.shippingMethod;
        }
        if (this.paymentMethod) {
            apiKeys[PM_API_ITEM] = this.paymentMethod;
        }
        if (this.totalRevenue) {
            apiKeys[TR_API_ITEM] = this.totalRevenue;
        }
        if (this.shippingCosts) {
            apiKeys[TS_API_ITEM] = this.shippingCosts;
        }
        return apiKeys;
    }
    toObject() {
        return {
            ...super.toObject(),
            transactionId: this.transactionId,
            affiliation: this.affiliation,
            taxes: this.taxes,
            currency: this.currency,
            couponCode: this.couponCode,
            itemCount: this.itemCount,
            shippingMethod: this.shippingMethod,
            paymentMethod: this.paymentMethod,
            totalRevenue: this.totalRevenue,
            shippingCosts: this.shippingCosts
        };
    }
    getErrorMessage() {
        return Transaction_ERROR_MESSAGE;
    }
}

;// ./src/api/TrackingManagerAbstract.ts














const LOOKUP_HITS_JSON_ERROR = 'JSON DATA must be an array of object';
const TrackingManagerAbstract_LOOKUP_HITS_JSON_OBJECT_ERROR = 'JSON DATA must fit the type HitCacheDTO';
class TrackingManagerAbstract {
    _httpClient;
    _config;
    _hitsPoolQueue;
    _activatePoolQueue;
    _troubleshootingQueue;
    _analyticHitQueue;
    strategy;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _intervalID;
    _isPooling = false;
    _flagshipInstanceId;
    _initTroubleshootingHit;
    _sharedActionTracking;
    get initTroubleshootingHit() {
        return this._initTroubleshootingHit;
    }
    set initTroubleshootingHit(v) {
        this._initTroubleshootingHit = v;
        this.strategy.initTroubleshootingHit = v;
    }
    get flagshipInstanceId() {
        return this._flagshipInstanceId;
    }
    get troubleshootingData() {
        return this.strategy.troubleshootingData;
    }
    set troubleshootingData(v) {
        this.strategy.troubleshootingData = v;
    }
    constructor(httpClient, config, flagshipInstanceId, sharedActionTracking) {
        this._flagshipInstanceId = flagshipInstanceId;
        this._hitsPoolQueue = new Map();
        this._activatePoolQueue = new Map();
        this._troubleshootingQueue = new Map();
        this._analyticHitQueue = new Map();
        this._httpClient = httpClient;
        this._config = config;
        this._sharedActionTracking = sharedActionTracking;
        this.strategy = this.initStrategy();
        this.lookupHits();
    }
    initStrategy() {
        let strategy;
        const argument = {
            config: this.config,
            httpClient: this.httpClient,
            hitsPoolQueue: this._hitsPoolQueue,
            activatePoolQueue: this._activatePoolQueue,
            troubleshootingQueue: this._troubleshootingQueue,
            analyticHitQueue: this._analyticHitQueue,
            flagshipInstanceId: this.flagshipInstanceId,
            initTroubleshootingHit: this.initTroubleshootingHit,
            sharedActionTracking: this._sharedActionTracking
        };
        switch (this.config.trackingManagerConfig?.cacheStrategy) {
            case CacheStrategy.PERIODIC_CACHING:
                strategy = new BatchingPeriodicCachingStrategy(argument);
                break;
            case CacheStrategy.CONTINUOUS_CACHING:
                strategy = new BatchingContinuousCachingStrategy(argument);
                break;
            default:
                strategy = new NoBatchingContinuousCachingStrategy(argument);
                break;
        }
        return strategy;
    }
    get httpClient() {
        return this._httpClient;
    }
    get config() {
        return this._config;
    }
    async sendTroubleshootingHit(hit) {
        await this.strategy.sendTroubleshootingHit(hit);
    }
    startBatchingLoop() {
        const batchIntervals = this.config.trackingManagerConfig?.batchIntervals;
        if (batchIntervals === 0) {
            return;
        }
        const timeInterval = batchIntervals * 1000;
        logInfoSprintf(this.config, TRACKING_MANAGER, BATCH_LOOP_STARTED, timeInterval);
        this._intervalID = setInterval(() => {
            this.batchingLoop();
        }, timeInterval);
    }
    stopBatchingLoop() {
        clearInterval(this._intervalID);
        this._isPooling = false;
        logInfo(this.config, BATCH_LOOP_STOPPED, TRACKING_MANAGER);
    }
    async batchingLoop() {
        if (this._isPooling) {
            return;
        }
        this._isPooling = true;
        await this.strategy.sendBatch(BatchTriggeredBy.Timer);
        await this.strategy.sendTroubleshootingQueue();
        await this.strategy.sendUsageHitQueue();
        this._isPooling = false;
    }
    checkLookupHitData(item) {
        if (item?.version === 1 && item?.data?.type && item?.data?.content) {
            return true;
        }
        logError(this.config, TrackingManagerAbstract_LOOKUP_HITS_JSON_OBJECT_ERROR, PROCESS_LOOKUP_HIT);
        return false;
    }
    async extractHitData(key, item) {
        let hit;
        switch (item.data.type) {
            case HitType.EVENT: {
                hit = new Event(item.data.content);
                break;
            }
            case HitType.ITEM: {
                hit = new Item(item.data.content);
                break;
            }
            case HitType.PAGE: {
                hit = new Page(item.data.content);
                break;
            }
            case HitType.SCREEN: {
                hit = new Screen(item.data.content);
                break;
            }
            case 'SEGMENT': {
                hit = new Segment(item.data.content);
                break;
            }
            case HitType.TRANSACTION: {
                hit = new Transaction(item.data.content);
                break;
            }
            default:
        }
        return hit;
    }
    async processCachedHits(hitsCache) {
        const checkHitTime = (time) => (((Date.now() - time)) <= DEFAULT_HIT_CACHE_TIME_MS);
        const wrongHitKeys = [];
        const entries = Object.entries(hitsCache);
        for (const [key, item] of entries) {
            if (!this.checkLookupHitData(item) || !checkHitTime(item.data.time)) {
                wrongHitKeys.push(key);
                continue;
            }
            if (item.data.type === 'ACTIVATE') {
                const hit = new Activate(item.data.content);
                hit.key = key;
                hit.createdAt = item.data.content.createdAt;
                hit.config = this.config;
                this._activatePoolQueue.set(key, hit);
                continue;
            }
            const hit = await this.extractHitData(key, item);
            if (!hit) {
                wrongHitKeys.push(key);
                continue;
            }
            hit.key = key;
            hit.createdAt = item.data.content.createdAt;
            hit.config = this.config;
            this._hitsPoolQueue.set(key, hit);
        }
        if (wrongHitKeys.length) {
            await this.strategy.flushHits(wrongHitKeys);
        }
    }
    async lookupHits() {
        try {
            const hitCacheImplementation = this.config.hitCacheImplementation;
            if (this.config.disableCache || !hitCacheImplementation || typeof hitCacheImplementation.lookupHits !== 'function') {
                return;
            }
            const hitsCache = await hitCacheImplementation.lookupHits();
            logDebugSprintf(this.config, PROCESS_CACHE, HIT_CACHE_LOADED, hitsCache);
            if (!hitsCache || !Object.keys(hitsCache).length) {
                return;
            }
            await this.processCachedHits(hitsCache);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, HIT_CACHE_ERROR, 'lookupHits', error.message || error);
        }
    }
    async sendUsageHit(hit) {
        await this.strategy.sendUsageHit(hit);
    }
    async addTroubleshootingHit(hit) {
        await this.strategy.addTroubleshootingHit(hit);
    }
}

;// ./src/api/TrackingManager.ts


class TrackingManager extends TrackingManagerAbstract {
    async activateFlag(hit) {
        await this.strategy.activateFlag(hit);
    }
    async addHit(hit) {
        await this.strategy.addHit(hit);
    }
    async sendBatch() {
        await this.strategy.sendBatch(BatchTriggeredBy.Flush);
    }
}

;// ./src/utils/FlagshipLogManager.ts
/* eslint-disable no-console */


class FlagshipLogManager {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consoleError;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consoleWarn;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consoleDebug;
    constructor() {
        this.consoleError = console.error ?? console.log;
        this.consoleWarn = console.warn ?? console.log;
        this.consoleDebug = console.debug ?? console.log;
    }
    emergency(message, tag) {
        this.consoleError(formatLogOutput(LogLevel.EMERGENCY, message, tag));
    }
    alert(message, tag) {
        this.consoleError(formatLogOutput(LogLevel.ALERT, message, tag));
    }
    critical(message, tag) {
        this.consoleError(formatLogOutput(LogLevel.CRITICAL, message, tag));
    }
    error(message, tag) {
        this.consoleError(formatLogOutput(LogLevel.ERROR, message, tag));
    }
    warning(message, tag) {
        this.consoleWarn(formatLogOutput(LogLevel.WARNING, message, tag));
    }
    notice(message, tag) {
        this.log(LogLevel.NOTICE, message, tag);
    }
    info(message, tag) {
        console.info(formatLogOutput(LogLevel.INFO, message, tag));
    }
    debug(message, tag) {
        this.consoleDebug(formatLogOutput(LogLevel.DEBUG, message, tag));
    }
    log(level, message, tag) {
        console.log(formatLogOutput(level, message, tag));
    }
}

;// ./src/hit/UsageHit.ts

class UsageHit extends Diagnostic {
    constructor(param) {
        super({
            ...param,
            type: 'USAGE'
        });
    }
}

;// ./src/visitor/StrategyAbstract.ts










const StrategyAbstract_LOOKUP_HITS_JSON_ERROR = 'JSON DATA must be an array of object';
const StrategyAbstract_LOOKUP_HITS_JSON_OBJECT_ERROR = 'JSON DATA must fit the type HitCacheDTO';
const VISITOR_ID_MISMATCH_ERROR = 'Visitor ID mismatch: {0} vs {1}';
class StrategyAbstract {
    visitor;
    get configManager() {
        return this.visitor.configManager;
    }
    get trackingManager() {
        return this.configManager.trackingManager;
    }
    get decisionManager() {
        return this.configManager.decisionManager;
    }
    get config() {
        return this.visitor.config;
    }
    _murmurHash;
    constructor(param) {
        const { visitor, murmurHash } = param;
        this.visitor = visitor;
        this._murmurHash = murmurHash;
    }
    collectEAIEventsAsync(currentPage) {
        return this.visitor.emotionAi.collectEAIEventsAsync(currentPage);
    }
    reportEaiVisitorEvent(event) {
        if (true) {
            Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 121)).then(({ VisitorEvent }) => {
                this.visitor.emotionAi.reportVisitorEvent(new VisitorEvent(event));
            });
        }
    }
    reportEaiPageView(pageView) {
        if (true) {
            Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 221)).then(({ PageView }) => {
                this.visitor.emotionAi.reportPageView(new PageView(pageView));
            });
        }
    }
    onEAICollectStatusChange(callback) {
        this.visitor.emotionAi.onEAICollectStatusChange(callback);
    }
    cleanup() {
        this.visitor.emotionAi.cleanup();
    }
    updateCampaigns(campaigns) {
        try {
            this.visitor.campaigns = campaigns;
            this.visitor.flagsData = this.decisionManager.getModifications(campaigns);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logError(this.config, error.message || error, 'updateCampaigns');
        }
    }
    hasTrackingManager(process) {
        const check = this.trackingManager;
        if (!check) {
            logError(this.config, sprintf(TRACKER_MANAGER_MISSING_ERROR), process);
        }
        return !!check;
    }
    setConsent(hasConsented) {
        const method = 'setConsent';
        this.visitor.hasConsented = hasConsented;
        if (!hasConsented) {
            this.flushVisitor();
        }
        if (!this.hasTrackingManager(method)) {
            return;
        }
        const consentHit = new Event({
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            label: `${SDK_INFO.name}:${this.visitor.hasConsented}`,
            action: FS_CONSENT,
            category: EventCategory.USER_ENGAGEMENT
        });
        consentHit.qaMode = this.config.isQAModeEnabled;
        consentHit.ds = SDK_APP;
        consentHit.config = this.config;
        this.trackingManager.addHit(consentHit);
        const hitTroubleshooting = new Troubleshooting({
            label: TroubleshootingLabel.VISITOR_SEND_HIT,
            logLevel: LogLevel.INFO,
            traffic: this.visitor.traffic || 0,
            visitorId: this.visitor.visitorId,
            visitorSessionId: this.visitor.instanceId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            anonymousId: this.visitor.anonymousId,
            config: this.config,
            hitContent: consentHit.toApiKeys()
        });
        if (this.decisionManager.troubleshooting) {
            this.trackingManager.sendTroubleshootingHit(hitTroubleshooting);
            return;
        }
        this.visitor.consentHitTroubleshooting = hitTroubleshooting;
        logDebugSprintf(this.config, PROCESS_SET_CONSENT, CONSENT_CHANGED, this.visitor.visitorId, hasConsented);
    }
    checKLookupVisitorDataV1(item) {
        if (!item || !item.data || !item.data.visitorId) {
            return false;
        }
        const campaigns = item.data.campaigns;
        if (!campaigns) {
            return true;
        }
        if (!Array.isArray(campaigns)) {
            return false;
        }
        if ((this.visitor.visitorCacheStatus === VisitorCacheStatus.VISITOR_ID_CACHE || this.visitor.visitorCacheStatus === VisitorCacheStatus.VISITOR_ID_CACHE_WITH_ANONYMOUS_ID_CACHE) && item.data.visitorId !== this.visitor.visitorId) {
            logInfoSprintf(this.config, PROCESS_CACHE, VISITOR_ID_MISMATCH_ERROR, item.data.visitorId, this.visitor.visitorId);
            return false;
        }
        if (this.visitor.visitorCacheStatus === VisitorCacheStatus.ANONYMOUS_ID_CACHE && item.data.visitorId !== this.visitor.anonymousId) {
            logInfoSprintf(this.config, PROCESS_CACHE, VISITOR_ID_MISMATCH_ERROR, item.data.visitorId, this.visitor.anonymousId);
            return false;
        }
        return campaigns.every(x => x.campaignId && x.type && x.variationGroupId && x.variationId);
    }
    checKLookupVisitorData(item) {
        if (item.version === 1) {
            return this.checKLookupVisitorDataV1(item);
        }
        return false;
    }
    async tryLookupCache(id) {
        const visitorCacheInstance = this.config.visitorCacheImplementation;
        if (!visitorCacheInstance || typeof visitorCacheInstance.lookupVisitor !== 'function') {
            return null;
        }
        return await visitorCacheInstance.lookupVisitor(id);
    }
    processValidCache(visitorCache) {
        if (!this.checKLookupVisitorData(visitorCache)) {
            logErrorSprintf(this.config, PROCESS_CACHE, LOOKUP_VISITOR_JSON_OBJECT_ERROR, VISITOR_CACHE_VERSION, this.visitor.visitorId);
            return false;
        }
        this.visitor.visitorCache = visitorCache;
        return true;
    }
    async lookupVisitor() {
        try {
            if (this.config.disableCache || this.visitor.visitorCache) {
                return;
            }
            this.visitor.visitorCacheStatus = VisitorCacheStatus.NONE;
            let visitorCache = await this.tryLookupCache(this.visitor.visitorId);
            if (visitorCache) {
                this.visitor.visitorCacheStatus = VisitorCacheStatus.VISITOR_ID_CACHE;
            }
            else if (this.visitor.anonymousId) {
                visitorCache = await this.tryLookupCache(this.visitor.anonymousId);
                if (visitorCache) {
                    this.visitor.visitorCacheStatus = VisitorCacheStatus.ANONYMOUS_ID_CACHE;
                }
            }
            logDebugSprintf(this.config, PROCESS_CACHE, VISITOR_CACHE_LOADED, this.visitor.visitorId, visitorCache);
            if (!visitorCache || !this.processValidCache(visitorCache)) {
                return;
            }
            if (this.visitor.visitorCacheStatus === VisitorCacheStatus.VISITOR_ID_CACHE && this.visitor.anonymousId) {
                const anonymousVisitorCache = await this.tryLookupCache(this.visitor.anonymousId);
                if (anonymousVisitorCache) {
                    this.visitor.visitorCacheStatus = VisitorCacheStatus.VISITOR_ID_CACHE_WITH_ANONYMOUS_ID_CACHE;
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, VISITOR_CACHE_ERROR, this.visitor.visitorId, 'lookupVisitor', error.message || error);
        }
    }
    createVisitorCacheDTO(eAIScore, isEAIDataCollected) {
        const assignmentsHistory = {};
        const visitorCacheDTO = {
            version: VISITOR_CACHE_VERSION,
            data: {
                visitorId: this.visitor.visitorId,
                anonymousId: this.visitor.anonymousId,
                consent: this.visitor.hasConsented,
                context: this.visitor.context,
                eAIScore: this.visitor.visitorCache?.data?.eAIScore || eAIScore,
                isEAIDataCollected: this.visitor.visitorCache?.data?.isEAIDataCollected || isEAIDataCollected,
                campaigns: this.visitor.campaigns.map(campaign => {
                    assignmentsHistory[campaign.variationGroupId] = campaign.variation.id;
                    return {
                        campaignId: campaign.id,
                        slug: campaign.slug,
                        variationGroupId: campaign.variationGroupId,
                        variationId: campaign.variation.id,
                        isReference: campaign.variation.reference,
                        type: campaign.variation.modifications.type,
                        activated: false,
                        flags: campaign.variation.modifications.value
                    };
                })
            }
        };
        visitorCacheDTO.data.assignmentsHistory = {
            ...this.visitor.visitorCache?.data?.assignmentsHistory,
            ...assignmentsHistory
        };
        return visitorCacheDTO;
    }
    async cacheAnonymousVisitor(visitorCacheInstance, visitorCacheDTO) {
        const visitorCacheStatus = this.visitor.visitorCacheStatus;
        if (this.visitor.anonymousId && (visitorCacheStatus === VisitorCacheStatus.NONE || visitorCacheStatus === VisitorCacheStatus.VISITOR_ID_CACHE)) {
            const anonymousVisitorCacheDTO = {
                ...visitorCacheDTO,
                data: {
                    ...visitorCacheDTO.data,
                    visitorId: this.visitor.anonymousId,
                    anonymousId: null
                }
            };
            await visitorCacheInstance.cacheVisitor(this.visitor.anonymousId, anonymousVisitorCacheDTO);
        }
    }
    async cacheVisitor(eAIScore, isEAIDataCollected) {
        try {
            const visitorCacheInstance = this.config.visitorCacheImplementation;
            if (this.config.disableCache || !visitorCacheInstance || typeof visitorCacheInstance.cacheVisitor !== 'function') {
                return;
            }
            const visitorCacheDTO = this.createVisitorCacheDTO(eAIScore, isEAIDataCollected);
            await visitorCacheInstance.cacheVisitor(this.visitor.visitorId, visitorCacheDTO);
            await this.cacheAnonymousVisitor(visitorCacheInstance, visitorCacheDTO);
            logDebugSprintf(this.config, PROCESS_CACHE, VISITOR_CACHE_SAVED, this.visitor.visitorId, visitorCacheDTO);
            this.visitor.visitorCache = visitorCacheDTO;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, VISITOR_CACHE_ERROR, this.visitor.visitorId, 'cacheVisitor', error.message || error);
        }
    }
    async flushVisitor() {
        try {
            const visitorCacheInstance = this.config.visitorCacheImplementation;
            if (this.config.disableCache || !visitorCacheInstance || typeof visitorCacheInstance.flushVisitor !== 'function') {
                return;
            }
            await visitorCacheInstance.flushVisitor(this.visitor.visitorId);
            logDebugSprintf(this.config, PROCESS_CACHE, VISITOR_CACHE_FLUSHED, this.visitor.visitorId);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this.config, PROCESS_CACHE, VISITOR_CACHE_ERROR, this.visitor.visitorId, 'flushVisitor', error.message || error);
        }
    }
    addInTrackingManager(hit) {
        return this.trackingManager.addHit(hit);
    }
    async sendTroubleshootingHit(hit) {
        await this.trackingManager.sendTroubleshootingHit(hit);
    }
    async sendUsageHit(hit) {
        if (this.config.disableDeveloperUsageTracking) {
            return;
        }
        const traffic = this.visitor.analyticTraffic;
        if (traffic > ANALYTIC_HIT_ALLOCATION) {
            return;
        }
        return this.trackingManager.sendUsageHit(hit);
    }
    getCurrentDateTime() {
        return new Date();
    }
    getSdkConfigDecisionMode() {
        return this.config.decisionMode === DecisionMode.DECISION_API ? 'DECISION_API' : this.config.decisionMode;
    }
    async sendSdkConfigAnalyticHit() {
        if (this.config.disableDeveloperUsageTracking) {
            return;
        }
        const hitCacheImplementation = this.config.hitCacheImplementation;
        const visitorCacheImplementation = this.config.visitorCacheImplementation;
        let sdkConfigUsingCustomHitCache = false;
        let sdkConfigUsingCustomVisitorCache = false;
        if (false) {}
        const analyticData = new UsageHit({
            label: TroubleshootingLabel.SDK_CONFIG,
            logLevel: LogLevel.INFO,
            visitorId: this.visitor.sdkInitialData?.instanceId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            config: this.config,
            sdkStatus: this.visitor.getSdkStatus(),
            lastBucketingTimestamp: this.configManager.decisionManager.lastBucketingTimestamp,
            lastInitializationTimestamp: this.visitor.sdkInitialData?.lastInitializationTimestamp,
            sdkConfigMode: this.getSdkConfigDecisionMode(),
            sdkConfigLogLevel: this.config.logLevel,
            sdkConfigTimeout: this.config.timeout,
            sdkConfigPollingInterval: this.config.pollingInterval,
            sdkConfigTrackingManagerStrategy: this.config.trackingManagerConfig?.cacheStrategy,
            sdkConfigTrackingManagerBatchIntervals: this.config.trackingManagerConfig?.batchIntervals,
            sdkConfigTrackingManagerPoolMaxSize: this.config.trackingManagerConfig?.poolMaxSize,
            sdkConfigFetchNow: this.config.fetchNow,
            sdkConfigReuseVisitorIds: this.config.reuseVisitorIds,
            sdkConfigInitialBucketing: this.config.initialBucketing,
            sdkConfigDecisionApiUrl: this.config.decisionApiUrl,
            sdkConfigHitDeduplicationTime: this.config.hitDeduplicationTime,
            sdkConfigUsingOnVisitorExposed: !!this.config.onVisitorExposed,
            sdkConfigUsingCustomHitCache: !!sdkConfigUsingCustomHitCache,
            sdkConfigUsingCustomVisitorCache: !!sdkConfigUsingCustomVisitorCache,
            sdkConfigFetchThirdPartyData: this.config.fetchThirdPartyData,
            sdkConfigFetchFlagsBufferingTime: this.config.fetchFlagsBufferingTime,
            sdkConfigDisableDeveloperUsageTracking: this.config.disableDeveloperUsageTracking,
            sdkConfigNextFetchConfig: this.config.nextFetchConfig,
            sdkConfigDisableCache: this.config.disableCache
        });
        this.sendUsageHit(analyticData);
    }
    async sendFetchFlagsTroubleshooting({ isFromCache, campaigns, now }) {
        const assignmentHistory = {};
        this.visitor.flagsData.forEach(item => {
            assignmentHistory[item.variationGroupId] = item.variationId;
        });
        const uniqueId = this.visitor.visitorId + this.decisionManager.troubleshooting?.endDate.toUTCString();
        const hash = this._murmurHash.murmurHash3Int32(uniqueId);
        const traffic = hash % 100;
        this.visitor.traffic = traffic;
        const hitCacheImplementation = this.config.hitCacheImplementation;
        const visitorCacheImplementation = this.config.visitorCacheImplementation;
        let sdkConfigUsingCustomHitCache = false;
        let sdkConfigUsingCustomVisitorCache = false;
        if (false) {}
        const fetchFlagTroubleshooting = new Troubleshooting({
            label: TroubleshootingLabel.VISITOR_FETCH_CAMPAIGNS,
            logLevel: LogLevel.INFO,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            visitorSessionId: this.visitor.instanceId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            traffic,
            config: this.config,
            sdkStatus: this.visitor.getSdkStatus(),
            visitorContext: this.visitor.context,
            visitorCampaigns: campaigns,
            visitorCampaignFromCache: isFromCache ? campaigns : undefined,
            visitorConsent: this.visitor.hasConsented,
            visitorIsAuthenticated: !!this.visitor.anonymousId,
            visitorFlags: this.visitor.flagsData,
            visitorAssignmentHistory: assignmentHistory,
            visitorInitialCampaigns: this.visitor.sdkInitialData?.initialCampaigns,
            visitorInitialFlagsData: this.visitor.sdkInitialData?.initialFlagsData,
            lastBucketingTimestamp: this.configManager.decisionManager.lastBucketingTimestamp,
            lastInitializationTimestamp: this.visitor.sdkInitialData?.lastInitializationTimestamp,
            httpResponseTime: Date.now() - now,
            sdkConfigLogLevel: this.config.logLevel,
            sdkConfigMode: this.getSdkConfigDecisionMode(),
            sdkConfigTimeout: this.config.timeout,
            sdkConfigPollingInterval: this.config.pollingInterval,
            sdkConfigTrackingManagerStrategy: this.config.trackingManagerConfig?.cacheStrategy,
            sdkConfigTrackingManagerBatchIntervals: this.config.trackingManagerConfig?.batchIntervals,
            sdkConfigTrackingManagerPoolMaxSize: this.config.trackingManagerConfig?.poolMaxSize,
            sdkConfigFetchNow: this.config.fetchNow,
            sdkConfigReuseVisitorIds: this.config.reuseVisitorIds,
            sdkConfigInitialBucketing: this.config.initialBucketing,
            sdkConfigDecisionApiUrl: this.config.decisionApiUrl,
            sdkConfigHitDeduplicationTime: this.config.hitDeduplicationTime,
            sdkConfigUsingOnVisitorExposed: !!this.config.onVisitorExposed,
            sdkConfigUsingCustomHitCache: !!sdkConfigUsingCustomHitCache,
            sdkConfigUsingCustomVisitorCache: !!sdkConfigUsingCustomVisitorCache,
            sdkConfigFetchThirdPartyData: this.config.fetchThirdPartyData,
            sdkConfigFetchFlagsBufferingTime: this.config.fetchFlagsBufferingTime,
            sdkConfigDisableDeveloperUsageTracking: this.config.disableDeveloperUsageTracking,
            sdkConfigNextFetchConfig: this.config.nextFetchConfig,
            sdkConfigDisableCache: this.config.disableCache
        });
        await this.sendTroubleshootingHit(fetchFlagTroubleshooting);
    }
    sendConsentHitTroubleshooting() {
        const consentHitTroubleshooting = this.visitor.consentHitTroubleshooting;
        if (!consentHitTroubleshooting) {
            return;
        }
        consentHitTroubleshooting.traffic = this.visitor.traffic;
        this.trackingManager.sendTroubleshootingHit(consentHitTroubleshooting);
        this.visitor.consentHitTroubleshooting = undefined;
    }
    sendSegmentHitTroubleshooting() {
        const segmentHitTroubleshooting = this.visitor.segmentHitTroubleshooting;
        if (!segmentHitTroubleshooting) {
            return;
        }
        segmentHitTroubleshooting.traffic = this.visitor.traffic;
        this.trackingManager.sendTroubleshootingHit(segmentHitTroubleshooting);
        this.visitor.segmentHitTroubleshooting = undefined;
    }
}

;// ./src/enum/FlagshipContext.ts
/**
     * Current device locale
     */
const DEVICE_LOCALE = 'sdk_deviceLanguage';
/**
  * Current device type  tablet, pc, server, iot, other

  */
const DEVICE_TYPE = 'sdk_deviceType';
/**
  * Current device model
  */
const DEVICE_MODEL = 'sdk_deviceModel';
/**
  * Current visitor city

  */
const LOCATION_CITY = 'sdk_city';
/**
  * Current visitor region

  */
const LOCATION_REGION = 'sdk_region';
/**
  * Current visitor country

  */
const LOCATION_COUNTRY = 'sdk_country';
/**
  * Current visitor latitude

  */
const LOCATION_LAT = 'sdk_lat';
/**
  * Current visitor longitude

  */
const LOCATION_LONG = 'sdk_long';
/**
  * Device public ip

  */
const IP = 'sdk_ip';
/**
  * OS name

  */
const OS_NAME = 'sdk_osName';
/**
  * OS version name

  */
const OS_VERSION_NAME = 'sdk_osVersionName';
/**
  * OS version code

  */
const OS_VERSION_CODE = 'sdk_osVersionCode';
/**
  * Carrier operator
  */
const CARRIER_NAME = 'sdk_carrierName';
/**
  * Internet connection type : 4G, 5G, Fiber

  */
const INTERNET_CONNECTION = 'sdk_internetConnection';
/**
  * Customer app version name

  */
const APP_VERSION_NAME = 'sdk_versionName';
/**
  * Customer app version code

  */
const APP_VERSION_CODE = 'sdk_versionCode';
/**
  * Current customer app interface name

  */
const INTERFACE_NAME = 'sdk_interfaceName';
/**
  * Flagship SDK client name

  */
const FLAGSHIP_CLIENT = 'fs_client';
/**
  * Flagship SDK version name

  */
const FLAGSHIP_VERSION = 'fs_version';
/**
  * Current visitor id

  */
const FLAGSHIP_VISITOR = 'fs_users';
const FLAGSHIP_CONTEXT = {
    [DEVICE_LOCALE]: 'string',
    [DEVICE_TYPE]: 'string',
    [DEVICE_MODEL]: 'string',
    [LOCATION_CITY]: 'string',
    [LOCATION_REGION]: 'string',
    [LOCATION_COUNTRY]: 'string',
    [LOCATION_LAT]: 'number',
    [LOCATION_LONG]: 'number',
    [IP]: 'string',
    [OS_NAME]: 'string',
    [OS_VERSION_NAME]: 'string',
    [OS_VERSION_CODE]: 'string',
    [CARRIER_NAME]: 'string',
    [INTERNET_CONNECTION]: 'string',
    [APP_VERSION_NAME]: 'string',
    [APP_VERSION_CODE]: 'string',
    [INTERFACE_NAME]: 'string',
    [FLAGSHIP_CLIENT]: 'string',
    [FLAGSHIP_VERSION]: 'string',
    [FLAGSHIP_VISITOR]: 'string'
};

;// ./src/flag/FSFlagMetadata.ts
class FSFlagMetadata {
    campaignId;
    campaignName;
    variationGroupId;
    variationGroupName;
    variationId;
    variationName;
    isReference;
    campaignType;
    slug;
    constructor(flagMetadata) {
        const { campaignId, variationGroupId, variationId, isReference, campaignType, slug, variationGroupName, variationName, campaignName } = flagMetadata;
        this.campaignId = campaignId;
        this.variationGroupId = variationGroupId;
        this.variationId = variationId;
        this.isReference = isReference;
        this.campaignType = campaignType;
        this.campaignName = campaignName;
        this.variationGroupName = variationGroupName;
        this.variationName = variationName;
        this.slug = slug;
    }
    static Empty() {
        return new FSFlagMetadata({
            campaignId: '',
            campaignName: '',
            campaignType: '',
            variationId: '',
            variationName: '',
            variationGroupId: '',
            variationGroupName: '',
            isReference: false,
            slug: null
        });
    }
}

;// ./src/enum/FSFetchStatus.ts
/**
 * Represents the status of the flags in the Flagship SDK.
 */
var FSFetchStatus;
(function (FSFetchStatus) {
    /**
     * The flags have been successfully fetched from the API or re-evaluated in bucketing mode.
     */
    FSFetchStatus["FETCHED"] = "FETCHED";
    /**
     * The flags are currently being fetched from the API or re-evaluated in bucketing mode.
     */
    FSFetchStatus["FETCHING"] = "FETCHING";
    /**
     * The flags need to be re-fetched due to a change in context, or because the flags were loaded from cache or XPC.
     */
    FSFetchStatus["FETCH_REQUIRED"] = "FETCH_REQUIRED";
    /**
     * The SDK is in PANIC mode: All features are disabled except for the one to fetch flags.
     */
    FSFetchStatus["PANIC"] = "PANIC";
    /**
     * The flags have been initialized from initial data provided during visitor creation .
     */
    FSFetchStatus["INITIAL_DATA"] = "INITIAL_DATA";
})(FSFetchStatus || (FSFetchStatus = {}));

;// ./src/visitor/DefaultStrategy.ts














const TYPE_HIT_REQUIRED_ERROR = 'property type is required and must ';
const HIT_NULL_ERROR = 'Hit must not be null';
class DefaultStrategy extends StrategyAbstract {
    checkPredefinedContext(key, value) {
        const type = FLAGSHIP_CONTEXT[key];
        if (!type) {
            return null;
        }
        let check = false;
        if (type === 'string') {
            check = typeof value === 'string';
        }
        else if (type === 'number') {
            check = typeof value === 'number';
        }
        if (!check) {
            logErrorSprintf(this.config, PROCESS_UPDATE_CONTEXT, PREDEFINED_CONTEXT_TYPE_ERROR, this.visitor.visitorId, key, type);
        }
        return check;
    }
    updateContextKeyValue(key, value) {
        const valueType = typeof value;
        if (typeof key !== 'string' || key === '') {
            logErrorSprintf(this.config, PROCESS_UPDATE_CONTEXT, CONTEXT_KEY_ERROR, this.visitor.visitorId, key);
            return;
        }
        if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') {
            logErrorSprintf(this.config, PROCESS_UPDATE_CONTEXT, CONTEXT_VALUE_ERROR, this.visitor.visitorId, key);
            return;
        }
        if (key === FLAGSHIP_CLIENT || key === FLAGSHIP_VERSION || key === FLAGSHIP_VISITOR) {
            return;
        }
        const predefinedContext = this.checkPredefinedContext(key, value);
        if (typeof predefinedContext === 'boolean' && !predefinedContext) {
            return;
        }
        this.visitor.context[key] = value;
    }
    checkAndUpdateContext(oldContext, newContext, value) {
        if (deepEqual(oldContext, newContext)) {
            return;
        }
        this.visitor.hasContextBeenUpdated = true;
        this.visitor.flagsStatus = {
            status: FSFetchStatus.FETCH_REQUIRED,
            reason: FSFetchReasons.UPDATE_CONTEXT
        };
        logDebugSprintf(this.config, PROCESS_UPDATE_CONTEXT, CONTEXT_KEY_VALUE_UPDATE, this.visitor.visitorId, newContext, value, this.visitor.context);
    }
    updateContext(context, value) {
        const oldContext = { ...this.visitor.context };
        if (typeof context === 'string') {
            this.updateContextKeyValue(context, value);
            const newContext = this.visitor.context;
            this.checkAndUpdateContext(oldContext, newContext, value);
            return;
        }
        if (!context) {
            logError(this.visitor.config, CONTEXT_NULL_ERROR, PROCESS_UPDATE_CONTEXT);
            return;
        }
        for (const key in context) {
            const value = context[key];
            this.updateContextKeyValue(key, value);
        }
        const newContext = this.visitor.context;
        this.checkAndUpdateContext(oldContext, newContext, context);
    }
    clearContext() {
        const oldContext = { ...this.visitor.context };
        this.visitor.context = {};
        this.visitor.loadPredefinedContext();
        const newContext = this.visitor.context;
        if (deepEqual(oldContext, newContext)) {
            return;
        }
        this.visitor.hasContextBeenUpdated = true;
        this.visitor.flagsStatus = {
            status: FSFetchStatus.FETCH_REQUIRED,
            reason: FSFetchReasons.UPDATE_CONTEXT
        };
        logDebugSprintf(this.config, PROCESS_CLEAR_CONTEXT, CLEAR_CONTEXT, this.visitor.visitorId, this.visitor.context);
    }
    isDeDuplicated(key, deDuplicationTime) {
        if (deDuplicationTime === 0) {
            return false;
        }
        const deDuplicationCache = this.visitor.deDuplicationCache[key];
        if (deDuplicationCache && (Date.now() - deDuplicationCache) <= (deDuplicationTime * 1000)) {
            return true;
        }
        this.visitor.deDuplicationCache[key] = Date.now();
        this.visitor.clearDeDuplicationCache(deDuplicationTime);
        return false;
    }
    async sendActivate(flagDto, defaultValue) {
        const activateHit = {
            variationGroupId: flagDto.variationGroupId,
            variationId: flagDto.variationId,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            flagKey: flagDto.key,
            flagValue: flagDto.value,
            flagDefaultValue: defaultValue,
            visitorContext: this.visitor.context,
            flagMetadata: {
                campaignName: flagDto.campaignName,
                campaignId: flagDto.campaignId,
                campaignType: flagDto.campaignType,
                variationGroupId: flagDto.variationGroupId,
                variationGroupName: flagDto.variationGroupName,
                variationId: flagDto.variationId,
                variationName: flagDto.variationName,
                slug: flagDto.slug,
                isReference: flagDto.isReference
            },
            qaMode: this.config.isQAModeEnabled
        };
        if (this.isDeDuplicated(JSON.stringify(activateHit), this.config.hitDeduplicationTime)) {
            const logData = {
                visitorId: this.visitor.visitorId,
                anonymousId: this.visitor.anonymousId,
                flag: flagDto,
                delay: 0
            };
            logDebug(this.config, sprintf('Activate {0} is deduplicated', JSON.stringify(logData)), PROCESS_SEND_HIT);
            return;
        }
        await this.trackingManager.activateFlag(activateHit);
        const activateTroubleshooting = new Troubleshooting({
            label: TroubleshootingLabel.VISITOR_SEND_ACTIVATE,
            logLevel: LogLevel.INFO,
            traffic: this.visitor.traffic,
            visitorId: activateHit.visitorId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            visitorSessionId: this.visitor.instanceId,
            anonymousId: activateHit.anonymousId,
            config: this.config,
            hitContent: activateHit
        });
        this.sendTroubleshootingHit(activateTroubleshooting);
    }
    async sendHit(hit) {
        if (!this.hasTrackingManager(PROCESS_SEND_HIT)) {
            return;
        }
        await this.prepareAndSendHit(hit);
    }
    async sendHits(hits) {
        if (!this.hasTrackingManager(PROCESS_SEND_HIT)) {
            return;
        }
        for (const hit of hits) {
            await this.prepareAndSendHit(hit);
        }
    }
    async getHit(hit) {
        let newHit = null;
        switch (hit.type.toUpperCase()) {
            case HitType.EVENT: {
                newHit = new Event(hit);
                break;
            }
            case HitType.ITEM: {
                newHit = new Item(hit);
                break;
            }
            case HitType.PAGE_VIEW: {
                newHit = new Page(hit);
                break;
            }
            case HitType.SCREEN_VIEW: {
                newHit = new Screen(hit);
                break;
            }
            case HitType.TRANSACTION: {
                newHit = new Transaction(hit);
                break;
            }
        }
        return newHit;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isHitAbstract(hit) {
        return hit &&
            typeof hit.toApiKeys === 'function' &&
            typeof hit.isReady === 'function' &&
            typeof hit.getErrorMessage === 'function' &&
            typeof hit.toObject === 'function';
    }
    async prepareAndSendHit(hit, functionName = PROCESS_SEND_HIT) {
        let hitInstance;
        if (!hit?.type) {
            logError(this.config, HIT_NULL_ERROR, functionName);
            return;
        }
        if (this.isHitAbstract(hit)) {
            hitInstance = hit;
        }
        else {
            const hitFromInt = await this.getHit(hit);
            if (!hitFromInt) {
                logError(this.config, TYPE_HIT_REQUIRED_ERROR, functionName);
                return;
            }
            hitInstance = hitFromInt;
        }
        hitInstance.visitorId = this.visitor.visitorId;
        hitInstance.ds = SDK_APP;
        hitInstance.config = this.config;
        hitInstance.anonymousId = this.visitor.anonymousId;
        hitInstance.qaMode = this.config.isQAModeEnabled;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { createdAt, ...hitInstanceItem } = hitInstance.toObject();
        if (this.isDeDuplicated(JSON.stringify(hitInstanceItem), this.config.hitDeduplicationTime)) {
            return;
        }
        if (!hitInstance.isReady()) {
            logError(this.config, hitInstance.getErrorMessage(), functionName);
            return;
        }
        try {
            await this.trackingManager.addHit(hitInstance);
            if (hitInstance.type === 'SEGMENT') {
                return;
            }
            const sendHitTroubleshooting = new Troubleshooting({
                label: TroubleshootingLabel.VISITOR_SEND_HIT,
                logLevel: LogLevel.INFO,
                traffic: this.visitor.traffic,
                visitorId: hitInstance.visitorId,
                flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
                visitorSessionId: this.visitor.instanceId,
                anonymousId: hitInstance.anonymousId,
                config: this.config,
                hitContent: hitInstance.toApiKeys()
            });
            this.sendTroubleshootingHit(sendHitTroubleshooting);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logError(this.config, error.message || error, functionName);
        }
    }
    authenticate(visitorId) {
        if (!visitorId) {
            logErrorSprintf(this.config, AUTHENTICATE, VISITOR_AUTHENTICATE_VISITOR_ID_ERROR, this.visitor.visitorId);
            return;
        }
        if (this.visitor.anonymousId) {
            logWarningSprintf(this.config, AUTHENTICATE, VISITOR_ALREADY_AUTHENTICATE, this.visitor.visitorId, this.visitor.anonymousId);
            return;
        }
        this.visitor.anonymousId = this.visitor.visitorId;
        this.visitor.visitorId = visitorId;
        const monitoring = new Troubleshooting({
            label: TroubleshootingLabel.VISITOR_AUTHENTICATE,
            logLevel: LogLevel.INFO,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            visitorContext: this.visitor.context,
            traffic: this.visitor.traffic,
            config: this.config
        });
        this.sendTroubleshootingHit(monitoring);
        this.visitor.flagsStatus = {
            status: FSFetchStatus.FETCH_REQUIRED,
            reason: FSFetchReasons.AUTHENTICATE
        };
        logDebugSprintf(this.config, AUTHENTICATE, VISITOR_AUTHENTICATE, this.visitor.visitorId, this.visitor.anonymousId);
    }
    unauthenticate() {
        if (!this.visitor.anonymousId) {
            logErrorSprintf(this.config, UNAUTHENTICATE, FLAGSHIP_VISITOR_NOT_AUTHENTICATE, this.visitor.visitorId);
            return;
        }
        this.visitor.visitorId = this.visitor.anonymousId;
        this.visitor.anonymousId = null;
        const monitoring = new Troubleshooting({
            label: TroubleshootingLabel.VISITOR_UNAUTHENTICATE,
            logLevel: LogLevel.INFO,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            visitorContext: this.visitor.context,
            traffic: this.visitor.traffic,
            config: this.config
        });
        this.sendTroubleshootingHit(monitoring);
        this.visitor.flagsStatus = {
            status: FSFetchStatus.FETCH_REQUIRED,
            reason: FSFetchReasons.UNAUTHENTICATE
        };
        logDebugSprintf(this.config, UNAUTHENTICATE, VISITOR_UNAUTHENTICATE, this.visitor.visitorId);
    }
    handleFetchFlagsError(error, now, campaigns) {
        this.visitor.emit(EMIT_READY, error);
        const message = error instanceof Error ? error.message : error;
        const errorMessage = errorFormat(message, {
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            context: this.visitor.context,
            statusReason: this.visitor.flagsStatus.reason,
            duration: Date.now() - now
        });
        logError(this.config, errorMessage, PROCESS_FETCHING_FLAGS);
        this.visitor.flagsStatus = {
            status: FSFetchStatus.FETCH_REQUIRED,
            reason: FSFetchReasons.FLAGS_FETCHING_ERROR
        };
        const troubleshootingHit = new Troubleshooting({
            label: TroubleshootingLabel.VISITOR_FETCH_CAMPAIGNS_ERROR,
            logLevel: LogLevel.INFO,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            visitorSessionId: this.visitor.instanceId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            traffic: this.visitor.traffic,
            config: this.config,
            visitorContext: this.visitor.context,
            sdkStatus: this.visitor.getSdkStatus(),
            visitorCampaigns: campaigns,
            visitorConsent: this.visitor.hasConsented,
            visitorIsAuthenticated: !!this.visitor.anonymousId,
            visitorFlags: this.visitor.flagsData,
            visitorInitialCampaigns: this.visitor.sdkInitialData?.initialCampaigns,
            visitorInitialFlagsData: this.visitor.sdkInitialData?.initialFlagsData,
            lastBucketingTimestamp: this.configManager.decisionManager.lastBucketingTimestamp,
            lastInitializationTimestamp: this.visitor.sdkInitialData?.lastInitializationTimestamp,
            httpResponseTime: Date.now() - now,
            sdkConfigMode: this.getSdkConfigDecisionMode(),
            sdkConfigTimeout: this.config.timeout,
            sdkConfigPollingInterval: this.config.pollingInterval,
            sdkConfigTrackingManagerStrategy: this.config.trackingManagerConfig?.cacheStrategy,
            sdkConfigTrackingManagerBatchIntervals: this.config.trackingManagerConfig?.batchIntervals,
            sdkConfigTrackingManagerPoolMaxSize: this.config.trackingManagerConfig?.poolMaxSize,
            sdkConfigFetchNow: this.config.fetchNow,
            sdkConfigReuseVisitorIds: this.config.reuseVisitorIds,
            sdkConfigInitialBucketing: this.config.initialBucketing,
            sdkConfigDecisionApiUrl: this.config.decisionApiUrl,
            sdkConfigHitDeduplicationTime: this.config.hitDeduplicationTime
        });
        this.trackingManager.addTroubleshootingHit(troubleshootingHit);
    }
    async getCampaigns(now) {
        let campaigns = null;
        const functionName = PROCESS_FETCHING_FLAGS;
        try {
            const time = Date.now() - this.visitor.lastFetchFlagsTimestamp;
            const fetchStatus = this.visitor.flagsStatus.status;
            if (fetchStatus === FSFetchStatus.FETCHING && this.visitor.getCampaignsPromise) {
                campaigns = await this.visitor.getCampaignsPromise;
                return {
                    campaigns,
                    isFetching: true
                };
            }
            const fetchFlagBufferingTime = (this.config.fetchFlagsBufferingTime * 1000);
            if (fetchStatus === FSFetchStatus.FETCHED && time < fetchFlagBufferingTime) {
                logInfoSprintf(this.config, functionName, FETCH_FLAGS_BUFFERING_MESSAGE, this.visitor.visitorId, fetchFlagBufferingTime - time);
                return {
                    campaigns,
                    isBuffered: true
                };
            }
            logDebugSprintf(this.config, functionName, FETCH_FLAGS_STARTED, this.visitor.visitorId);
            this.visitor.flagsStatus = {
                status: FSFetchStatus.FETCHING,
                reason: FSFetchReasons.NONE
            };
            await this.lookupVisitor();
            await this.visitor.emotionAi.fetchEAIScore();
            this.visitor.getCampaignsPromise = this.decisionManager.getCampaignsAsync(this.visitor);
            campaigns = await this.visitor.getCampaignsPromise;
            this.visitor.lastFetchFlagsTimestamp = Date.now();
            if (this.decisionManager.isPanic()) {
                this.visitor.flagsStatus = {
                    status: FSFetchStatus.PANIC,
                    reason: FSFetchReasons.NONE
                };
            }
            this.configManager.trackingManager.troubleshootingData = this.decisionManager.troubleshooting;
            logDebugSprintf(this.config, functionName, FETCH_CAMPAIGNS_SUCCESS, this.visitor.visitorId, this.visitor.anonymousId, this.visitor.context, campaigns, (Date.now() - now));
            return { campaigns };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logError(this.config, error.message, PROCESS_FETCHING_FLAGS);
            this.visitor.flagsStatus = {
                status: FSFetchStatus.FETCH_REQUIRED,
                reason: FSFetchReasons.FLAGS_FETCHING_ERROR
            };
            return {
                error: error,
                campaigns
            };
        }
    }
    fetchCampaignsFromCache(visitor) {
        if (!Array.isArray(visitor?.visitorCache?.data.campaigns)) {
            return null;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return visitor.visitorCache.data.campaigns.map((campaign) => {
            return {
                id: campaign.campaignId,
                variationGroupId: campaign.variationGroupId,
                slug: campaign.slug,
                variation: {
                    id: campaign.variationId,
                    reference: !!campaign.isReference,
                    modifications: {
                        type: campaign.type,
                        value: campaign.flags
                    }
                }
            };
        });
    }
    handleNoCampaigns(now) {
        const campaigns = this.fetchCampaignsFromCache(this.visitor);
        if (campaigns) {
            this.visitor.flagsStatus = {
                status: FSFetchStatus.FETCH_REQUIRED,
                reason: FSFetchReasons.FLAGS_FETCHED_FROM_CACHE
            };
            logDebugSprintf(this.config, PROCESS_FETCHING_FLAGS, FETCH_CAMPAIGNS_FROM_CACHE, this.visitor.visitorId, this.visitor.anonymousId, this.visitor.context, campaigns, Date.now() - now);
        }
        return campaigns;
    }
    sendVisitorAllocatedVariations() {
        if (false) {}
    }
    extractFlags(campaigns) {
        const flags = new Map();
        campaigns.forEach((campaign) => {
            const object = campaign.variation.modifications.value;
            for (const key in object) {
                const value = object[key];
                flags.set(key, {
                    key,
                    campaignId: campaign.id,
                    campaignName: campaign.name || '',
                    variationGroupId: campaign.variationGroupId,
                    variationGroupName: campaign.variationGroupName || '',
                    variationId: campaign.variation.id,
                    variationName: campaign.variation.name || '',
                    isReference: !!campaign.variation.reference,
                    campaignType: campaign.type,
                    slug: campaign.slug,
                    value
                });
            }
        });
        return flags;
    }
    async fetchFlags() {
        const now = Date.now();
        let campaigns = null;
        const { campaigns: fetchedCampaigns, error: fetchCampaignError, isFetching, isBuffered } = await this.getCampaigns(now);
        if (isFetching || isBuffered) {
            return;
        }
        campaigns = fetchedCampaigns;
        try {
            if (!campaigns) {
                campaigns = this.handleNoCampaigns(now);
            }
            campaigns = campaigns || [];
            this.visitor.campaigns = campaigns;
            this.visitor.flagsData = this.extractFlags(this.visitor.campaigns);
            this.cacheVisitor();
            this.visitor.emit(EMIT_READY, fetchCampaignError);
            if (this.visitor.flagsStatus.status === FSFetchStatus.FETCHING) {
                this.visitor.flagsStatus = {
                    status: FSFetchStatus.FETCHED,
                    reason: FSFetchReasons.NONE
                };
            }
            this.sendVisitorAllocatedVariations();
            logDebugSprintf(this.config, PROCESS_FETCHING_FLAGS, FETCH_FLAGS_FROM_CAMPAIGNS, this.visitor.visitorId, this.visitor.anonymousId, this.visitor.context, this.visitor.flagsData);
            if (this.decisionManager.troubleshooting) {
                this.sendFetchFlagsTroubleshooting({
                    campaigns,
                    now,
                    isFromCache: this.visitor.flagsStatus.reason === FSFetchReasons.FLAGS_FETCHED_FROM_CACHE
                });
                this.sendConsentHitTroubleshooting();
                this.sendSegmentHitTroubleshooting();
            }
            this.sendSdkConfigAnalyticHit();
        }
        catch (error) {
            this.handleFetchFlagsError(error, now, campaigns);
        }
    }
    async visitorExposed(param) {
        const { key, flag, defaultValue, hasGetValueBeenCalled } = param;
        if (!flag) {
            logWarningSprintf(this.visitor.config, FLAG_VISITOR_EXPOSED, USER_EXPOSED_FLAG_ERROR, this.visitor.visitorId, key);
            this.sendFlagTroubleshooting(TroubleshootingLabel.VISITOR_EXPOSED_FLAG_NOT_FOUND, key, defaultValue);
            return;
        }
        if (!hasGetValueBeenCalled) {
            logWarningSprintf(this.visitor.config, FLAG_VISITOR_EXPOSED, VISITOR_EXPOSED_VALUE_NOT_CALLED, this.visitor.visitorId, key);
            this.sendFlagTroubleshooting(TroubleshootingLabel.FLAG_VALUE_NOT_CALLED, key, defaultValue, true);
            return;
        }
        if (defaultValue !== null && defaultValue !== undefined && flag.value !== null && !hasSameType(flag.value, defaultValue)) {
            logWarningSprintf(this.visitor.config, FLAG_VISITOR_EXPOSED, USER_EXPOSED_CAST_ERROR, this.visitor.visitorId, key);
            this.sendFlagTroubleshooting(TroubleshootingLabel.VISITOR_EXPOSED_TYPE_WARNING, key, defaultValue);
            return;
        }
        await this.sendActivate(flag, defaultValue);
    }
    sendFlagTroubleshooting(label, key, defaultValue, visitorExposed) {
        const troubleshooting = new Troubleshooting({
            label,
            logLevel: LogLevel.WARNING,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            visitorSessionId: this.visitor.instanceId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            traffic: this.visitor.traffic,
            config: this.config,
            visitorContext: this.visitor.context,
            flagKey: key,
            flagDefault: defaultValue,
            visitorExposed
        });
        this.sendTroubleshootingHit(troubleshooting);
    }
    getFlagValue(param) {
        const { key, defaultValue, flag, visitorExposed } = param;
        if (!flag) {
            logWarningSprintf(this.config, FLAG_VALUE, GET_FLAG_MISSING_ERROR, this.visitor.visitorId, key, defaultValue);
            this.sendFlagTroubleshooting(TroubleshootingLabel.GET_FLAG_VALUE_FLAG_NOT_FOUND, key, defaultValue, visitorExposed);
            return defaultValue;
        }
        if (visitorExposed) {
            this.sendActivate(flag, defaultValue);
        }
        if (flag.value === null) {
            return defaultValue;
        }
        if (defaultValue !== null && defaultValue !== undefined && !hasSameType(flag.value, defaultValue)) {
            logWarningSprintf(this.config, FLAG_VALUE, GET_FLAG_CAST_ERROR, this.visitor.visitorId, key, defaultValue);
            this.sendFlagTroubleshooting(TroubleshootingLabel.GET_FLAG_VALUE_TYPE_WARNING, key, defaultValue, visitorExposed);
            return defaultValue;
        }
        logDebugSprintf(this.config, FLAG_VALUE, GET_FLAG_VALUE, this.visitor.visitorId, key, flag.value);
        return flag.value;
    }
    SendFlagMetadataTroubleshooting(key) {
        logWarningSprintf(this.config, FLAG_METADATA, NO_FLAG_METADATA, this.visitor.visitorId, key);
        const monitoring = new Troubleshooting({
            label: TroubleshootingLabel.GET_FLAG_METADATA_TYPE_WARNING,
            logLevel: LogLevel.WARNING,
            visitorId: this.visitor.visitorId,
            anonymousId: this.visitor.anonymousId,
            visitorSessionId: this.visitor.instanceId,
            flagshipInstanceId: this.visitor.sdkInitialData?.instanceId,
            traffic: this.visitor.traffic,
            config: this.config,
            visitorContext: this.visitor.context,
            flagKey: key
        });
        this.sendTroubleshootingHit(monitoring);
    }
    getFlagMetadata(param) {
        const { key, flag } = param;
        if (!flag) {
            logWarningSprintf(this.config, FLAG_METADATA, NO_FLAG_METADATA, this.visitor.visitorId, key);
            this.SendFlagMetadataTroubleshooting(key);
            return FSFlagMetadata.Empty();
        }
        const metadata = new FSFlagMetadata({
            campaignId: flag.campaignId,
            campaignName: flag.campaignName,
            variationGroupId: flag.variationGroupId,
            variationGroupName: flag.variationGroupName,
            variationId: flag.variationId,
            variationName: flag.variationName,
            isReference: !!flag.isReference,
            campaignType: flag.campaignType,
            slug: flag.slug
        });
        return metadata;
    }
}

;// ./src/visitor/NotReadyStrategy.ts




class NotReadyStrategy extends DefaultStrategy {
    async lookupHits() {
        //
    }
    async lookupVisitor() {
        //
    }
    async cacheVisitor() {
        //
    }
    async collectEAIEventsAsync() {
        this.log('collectEAIData');
    }
    onEAICollectStatusChange() {
        //
    }
    reportEaiPageView() {
        //
    }
    reportEaiVisitorEvent() {
        //
    }
    sendVisitorAllocatedVariations() {
        //
    }
    async sendHit(_hit) {
        this.log('sendHit');
    }
    async sendHits(_hits) {
        this.log('sendHits');
    }
    async fetchFlags() {
        this.log('fetchFlags');
    }
    getFlagValue(param) {
        this.log('Flag.value');
        return param.defaultValue;
    }
    async visitorExposed() {
        this.log(FLAG_VISITOR_EXPOSED);
    }
    getFlagMetadata(param) {
        const emptyMetaData = FSFlagMetadata.Empty();
        logErrorSprintf(this.config, FLAG_METADATA, METADATA_SDK_NOT_READY, this.visitor.visitorId, param.key, emptyMetaData);
        return emptyMetaData;
    }
    async sendActivate(_flagDto, _defaultValue) {
        //
    }
    async sendTroubleshootingHit() {
        //
    }
    async sendSdkConfigAnalyticHit() {
        //
    }
    async addInTrackingManager() {
        //
    }
    log(methodName) {
        logErrorSprintf(this.config, methodName, METHOD_DEACTIVATED_ERROR, this.visitor.visitorId, methodName, FSSdkStatus[FSSdkStatus.SDK_NOT_INITIALIZED]);
    }
}

;// ./src/visitor/PanicStrategy.ts




class PanicStrategy extends DefaultStrategy {
    setConsent(hasConsented) {
        this.visitor.hasConsented = hasConsented;
    }
    updateContext() {
        this.log('updateContext');
    }
    clearContext() {
        this.log('clearContext');
    }
    async lookupHits() {
        //
    }
    async lookupVisitor() {
        //
    }
    async cacheVisitor() {
        //
    }
    async cacheHit() {
        //
    }
    fetchCampaignsFromCache() {
        return [];
    }
    sendVisitorAllocatedVariations() {
        //
    }
    async sendHit(_hit) {
        this.log('sendHit');
    }
    async sendHits(_hits) {
        this.log('sendHits');
    }
    getFlagValue(param) {
        this.log('Flag.value');
        return param.defaultValue;
    }
    async visitorExposed() {
        this.log(FLAG_VISITOR_EXPOSED);
    }
    getFlagMetadata(param) {
        const emptyMetaData = FSFlagMetadata.Empty();
        logInfoSprintf(this.config, FLAG_METADATA, METADATA_PANIC_MODE, this.visitor.visitorId, param.key, emptyMetaData);
        return emptyMetaData;
    }
    async sendTroubleshootingHit() {
        //
    }
    async sendSdkConfigAnalyticHit() {
        //
    }
    async sendActivate(_flagDto, _defaultValue) {
        //
    }
    async collectEAIEventsAsync() {
        this.log('collectEAIData');
    }
    reportEaiPageView() {
        //
    }
    reportEaiVisitorEvent() {
        //
    }
    onEAICollectStatusChange() {
        //
    }
    async addInTrackingManager() {
        //
    }
    log(methodName) {
        logInfoSprintf(this.config, methodName, METHOD_DEACTIVATED_ERROR, this.visitor.visitorId, methodName, FSSdkStatus[FSSdkStatus.SDK_PANIC]);
    }
}

;// ./src/visitor/NoConsentStrategy.ts



class NoConsentStrategy extends DefaultStrategy {
    async lookupHits() {
        //
    }
    async lookupVisitor() {
        //
    }
    async cacheVisitor() {
        //
    }
    async cacheHit() {
        //
    }
    async collectEAIEventsAsync() {
        this.log('collectEAIData');
    }
    reportEaiPageView() {
        //
    }
    reportEaiVisitorEvent() {
        //
    }
    onEAICollectStatusChange() {
        //
    }
    fetchCampaignsFromCache() {
        return [];
    }
    async sendHit(_hit) {
        this.log('sendHit');
    }
    async sendHits(_hits) {
        this.log('sendHits');
    }
    async sendActivate(_flagDto, _defaultValue) {
        //
    }
    async visitorExposed() {
        this.log(FLAG_VISITOR_EXPOSED);
    }
    async sendTroubleshootingHit() {
        //
    }
    async addInTrackingManager() {
        //
    }
    log(methodName) {
        logInfo(this.config, sprintf(METHOD_DEACTIVATED_CONSENT_ERROR, methodName, this.visitor.visitorId), methodName);
    }
}

;// ./src/utils/MurmurHash.ts
/* eslint-disable no-fallthrough */
class MurmurHash {
    murmurHash3Int32(key, seed = 0) {
        let h1, h1b, k1, i;
        const remainder = key.length & 3; // key.length % 4
        const bytes = key.length - remainder;
        h1 = seed;
        const c1 = 0xcc9e2d51;
        const c2 = 0x1b873593;
        i = 0;
        while (i < bytes) {
            k1 = (key.charCodeAt(i) & 0xff) | ((key.charCodeAt(++i) & 0xff) << 8) | ((key.charCodeAt(++i) & 0xff) << 16) | ((key.charCodeAt(++i) & 0xff) << 24);
            ++i;
            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
            h1 ^= k1;
            h1 = (h1 << 13) | (h1 >>> 19);
            h1b = (((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16)) & 0xffffffff;
            h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
        }
        k1 = 0;
        switch (remainder) {
            case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
            case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
            case 1:
                k1 ^= (key.charCodeAt(i) & 0xff);
                k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
                k1 = (k1 << 15) | (k1 >>> 17);
                k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
                h1 ^= k1;
        }
        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
        h1 ^= h1 >>> 13;
        h1 = (((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
    }
}

;// ./src/visitor/VisitorAbstract.ts











class VisitorAbstract extends external_events_namespaceObject.EventEmitter {
    _visitorId;
    _context;
    _flags;
    _configManager;
    _campaigns;
    _hasConsented;
    _anonymousId;
    deDuplicationCache;
    _isCleaningDeDuplicationCache;
    visitorCache;
    _exposedVariations;
    _sendExposedVariationTimeoutId;
    _instanceId;
    _traffic;
    _sdkInitialData;
    _consentHitTroubleshooting;
    _segmentHitTroubleshooting;
    _fetchStatus;
    _onFetchFlagsStatusChanged;
    _getCampaignsPromise;
    _hasContextBeenUpdated;
    _emotionAi;
    _analyticTraffic;
    _murmurHash;
    _visitorProfileCache;
    _isClientSuppliedID;
    _visitorVariationState;
    get visitorVariationState() {
        return this._visitorVariationState;
    }
    get isClientSuppliedID() {
        return this._isClientSuppliedID;
    }
    get hasContextBeenUpdated() {
        return this._hasContextBeenUpdated;
    }
    set hasContextBeenUpdated(v) {
        this._hasContextBeenUpdated = v;
    }
    get getCampaignsPromise() {
        return this._getCampaignsPromise;
    }
    set getCampaignsPromise(v) {
        this._getCampaignsPromise = v;
    }
    get onFetchFlagsStatusChanged() {
        return this._onFetchFlagsStatusChanged;
    }
    set onFetchFlagsStatusChanged(v) {
        this._onFetchFlagsStatusChanged = v;
    }
    get flagsStatus() {
        return this._fetchStatus;
    }
    set flagsStatus(v) {
        this._fetchStatus = v;
        if (this.onFetchFlagsStatusChanged) {
            this.onFetchFlagsStatusChanged(v);
        }
    }
    get segmentHitTroubleshooting() {
        return this._segmentHitTroubleshooting;
    }
    set segmentHitTroubleshooting(v) {
        this._segmentHitTroubleshooting = v;
    }
    get consentHitTroubleshooting() {
        return this._consentHitTroubleshooting;
    }
    set consentHitTroubleshooting(v) {
        this._consentHitTroubleshooting = v;
    }
    get sdkInitialData() {
        return this._sdkInitialData;
    }
    static SdkStatus;
    getSdkStatus() {
        return VisitorAbstract.SdkStatus;
    }
    lastFetchFlagsTimestamp = 0;
    _visitorCacheStatus;
    get visitorCacheStatus() {
        return this._visitorCacheStatus;
    }
    set visitorCacheStatus(v) {
        this._visitorCacheStatus = v;
    }
    get emotionAi() {
        return this._emotionAi;
    }
    get analyticTraffic() {
        return this._analyticTraffic;
    }
    initBaseProperties(param) {
        const { configManager, emotionAi, monitoringData, visitorProfileCache } = param;
        this._murmurHash = param.murmurHash || new MurmurHash();
        this._emotionAi = emotionAi;
        this._hasContextBeenUpdated = true;
        this._exposedVariations = {};
        this._sdkInitialData = monitoringData;
        this._instanceId = uuidV4();
        this._isCleaningDeDuplicationCache = false;
        this.deDuplicationCache = {};
        this._context = {};
        this._configManager = configManager;
        this.campaigns = [];
        this._visitorProfileCache = visitorProfileCache;
    }
    /**
     * Attempts to retrieve a visitor ID from the ABTasty tag in browser environments
     * @returns The ABTasty visitor ID if available, otherwise undefined
     */
    getVisitorIdFromTag() {
        if (false) {}
        return undefined;
    }
    hasVisitorProfileClientSuppliedId(visitorProfileCache) {
        return visitorProfileCache.isClientSuppliedId === undefined ? true : visitorProfileCache.isClientSuppliedId;
    }
    initVisitorId(visitorId, isAuthenticated, hasConsented) {
        const shouldUseCache = this.config.reuseVisitorIds && hasConsented === true;
        const visitorCache = shouldUseCache ? this._visitorProfileCache?.loadVisitorProfile() : null;
        if (visitorCache) {
            logDebugSprintf(this.config, PROCESS_NEW_VISITOR, VISITOR_PROFILE_LOADED, visitorCache);
        }
        this._isClientSuppliedID = false;
        if (visitorId) {
            this.visitorId = visitorId;
            this._isClientSuppliedID = true;
        }
        else if (!isAuthenticated && visitorCache?.anonymousId) {
            this.visitorId = visitorCache.anonymousId;
            this._isClientSuppliedID = this.hasVisitorProfileClientSuppliedId(visitorCache);
        }
        else if (visitorCache?.visitorId) {
            this.visitorId = visitorCache.visitorId;
            this._isClientSuppliedID = this.hasVisitorProfileClientSuppliedId(visitorCache);
        }
        else {
            this.visitorId = this.getVisitorIdFromTag() || this.generateVisitorId();
        }
        this._anonymousId = null;
        if (isAuthenticated) {
            this._anonymousId = visitorCache?.anonymousId || uuidV4();
        }
    }
    constructor(param) {
        const { visitorId, context, isAuthenticated, hasConsented, initialFlagsData, initialCampaigns, onFlagsStatusChanged: onFetchFlagsStatusChanged } = param;
        super();
        this._visitorVariationState = param.visitorVariationState || {};
        this.initBaseProperties(param);
        this.initVisitorId(visitorId, isAuthenticated, hasConsented);
        this.initAnalyticTraffic();
        this.setConsent(hasConsented || false);
        this.updateContext(context);
        this.loadPredefinedContext();
        logDebugSprintf(this.config, PROCESS_NEW_VISITOR, PREDEFINED_CONTEXT_LOADED, {
            fs_client: SDK_INFO.name,
            fs_version: SDK_INFO.version,
            fs_users: this.visitorId
        });
        this.updateCache();
        const strategy = this.getStrategy();
        this.setInitialFlags(initialFlagsData, strategy);
        this.setInitializeCampaigns(initialCampaigns, !!initialFlagsData, strategy);
        this.onFetchFlagsStatusChanged = onFetchFlagsStatusChanged;
        this.updateFlagsStatus();
        this._emotionAi.init(this);
        logDebugSprintf(this.config, PROCESS_NEW_VISITOR, VISITOR_CREATED, this.visitorId, this.context, !!isAuthenticated, !!this.hasConsented);
    }
    updateFlagsStatus() {
        if (this._flags.size > 0) {
            this.flagsStatus = {
                status: FSFetchStatus.INITIAL_DATA,
                reason: FSFetchReasons.NONE
            };
            return;
        }
        this.flagsStatus = {
            status: FSFetchStatus.FETCH_REQUIRED,
            reason: FSFetchReasons.FLAGS_NEVER_FETCHED
        };
    }
    updateCache() {
        const visitorProfile = this.hasConsented ? {
            visitorId: this.visitorId,
            anonymousId: this.anonymousId,
            isClientSuppliedId: this.isClientSuppliedID
        } : undefined;
        this._visitorProfileCache?.saveVisitorProfile(visitorProfile);
    }
    get traffic() {
        return this._traffic;
    }
    set traffic(v) {
        this._traffic = v;
    }
    get instanceId() {
        return this._instanceId;
    }
    getCurrentDateTime() {
        return new Date();
    }
    initAnalyticTraffic() {
        const uniqueId = this.visitorId + this.getCurrentDateTime().toDateString();
        const hash = this._murmurHash.murmurHash3Int32(uniqueId);
        this._analyticTraffic = hash % 1000;
    }
    generateVisitorId() {
        const visitorId = uuidV4();
        logDebugSprintf(this.config, PROCESS_NEW_VISITOR, VISITOR_ID_GENERATED, visitorId);
        return visitorId;
    }
    clearDeDuplicationCache(deDuplicationTime) {
        if (this._isCleaningDeDuplicationCache) {
            return;
        }
        this._isCleaningDeDuplicationCache = true;
        const entries = Object.entries(this.deDuplicationCache);
        for (const [key, value] of entries) {
            if ((Date.now() - value) > (deDuplicationTime * 1000)) {
                delete this.deDuplicationCache[key];
            }
        }
        this._isCleaningDeDuplicationCache = false;
    }
    setInitialFlags(flags, strategy) {
        this._flags = new Map();
        if (!Array.isArray(flags)) {
            return;
        }
        flags.forEach((item) => {
            this._flags.set(item.key, {
                key: item.key,
                campaignId: item.campaignId,
                campaignName: item.campaignName,
                variationGroupId: item.variationGroupId,
                variationGroupName: item.variationGroupName,
                variationId: item.variationId,
                variationName: item.variationName,
                isReference: item.isReference,
                value: hexToValue(item.hex, this.config)?.v,
                slug: item.slug,
                campaignType: item.campaignType
            });
        });
        strategy?.sendVisitorAllocatedVariations();
    }
    setInitializeCampaigns(campaigns, hasInitialFlags, strategy) {
        if (campaigns && Array.isArray(campaigns) && !hasInitialFlags) {
            strategy?.updateCampaigns(campaigns);
            strategy?.sendVisitorAllocatedVariations();
        }
    }
    loadPredefinedContext() {
        this.context.fs_client = SDK_INFO.name;
        this.context.fs_version = SDK_INFO.version;
        this.context.fs_users = this.visitorId;
    }
    get visitorId() {
        return this._visitorId;
    }
    set visitorId(v) {
        if (!v || typeof v !== 'string') {
            logError(this.config, VISITOR_ID_ERROR, 'VISITOR ID');
            return;
        }
        this._visitorId = v;
        this.loadPredefinedContext();
        this.visitorCache = undefined;
    }
    get hasConsented() {
        return this._hasConsented;
    }
    set hasConsented(v) {
        this._hasConsented = v;
    }
    setConsent(hasConsented) {
        this.hasConsented = hasConsented;
        this.getStrategy().setConsent(hasConsented);
    }
    get context() {
        return this._context;
    }
    set context(v) {
        this._context = {};
        this.updateContext(v);
    }
    get flagsData() {
        return this._flags;
    }
    set flagsData(v) {
        this._flags = v;
    }
    get configManager() {
        return this._configManager;
    }
    get config() {
        return this.configManager.config;
    }
    get campaigns() {
        return this._campaigns;
    }
    set campaigns(v) {
        this._campaigns = v;
    }
    get anonymousId() {
        return this._anonymousId;
    }
    set anonymousId(v) {
        this._anonymousId = v;
    }
    getStrategy() {
        let strategy;
        const params = {
            visitor: this,
            murmurHash: new MurmurHash()
        };
        const status = this.getSdkStatus();
        if (status === undefined || status === FSSdkStatus.SDK_NOT_INITIALIZED) {
            strategy = new NotReadyStrategy(params);
        }
        else if (status === FSSdkStatus.SDK_PANIC) {
            strategy = new PanicStrategy(params);
        }
        else if (!this.hasConsented) {
            strategy = new NoConsentStrategy(params);
        }
        else {
            strategy = new DefaultStrategy(params);
        }
        return strategy;
    }
    async sendExposedVariation(flag) {
        if (false) {}
    }
    collectEAIEventsAsync(currentPage) {
        return this.getStrategy().collectEAIEventsAsync(currentPage);
    }
    sendEaiVisitorEvent(event) {
        this.getStrategy().reportEaiVisitorEvent(event);
    }
    sendEaiPageView(pageView) {
        this.getStrategy().reportEaiPageView(pageView);
    }
    onEAICollectStatusChange(callback) {
        this.getStrategy().onEAICollectStatusChange(callback);
    }
    cleanup() {
        this.getStrategy().cleanup();
    }
    async getCachedEAIScore() {
        if (!this.visitorCache) {
            await this.getStrategy().lookupVisitor();
        }
        return this.visitorCache?.data?.eAIScore;
    }
    async isEAIDataCollected() {
        if (!this.visitorCache) {
            await this.getStrategy().lookupVisitor();
        }
        return this.visitorCache?.data?.isEAIDataCollected || false;
    }
    async setCachedEAIScore(eAIScore) {
        this.getStrategy().cacheVisitor(eAIScore);
    }
    async setIsEAIDataCollected(isEAIDataCollected) {
        this.getStrategy().cacheVisitor(undefined, isEAIDataCollected);
    }
    sendTroubleshooting(hit) {
        return this.getStrategy().sendTroubleshootingHit(hit);
    }
    sendUsageHit(hit) {
        return this.getStrategy().sendUsageHit(hit);
    }
    addInTrackingManager(hit) {
        return this.getStrategy().addInTrackingManager(hit);
    }
}

;// ./src/enum/FSFlagStatus.ts
/**
 * Represents the status of the flags in the Flagship SDK.
 */
var FSFlagStatus;
(function (FSFlagStatus) {
    /**
     * The flags have been successfully fetched from the API or re-evaluated in bucketing mode.
     */
    FSFlagStatus["FETCHED"] = "FETCHED";
    /**
     * The flags need to be re-fetched due to a change in context, or because the flags were loaded from cache or XPC.
     */
    FSFlagStatus["FETCH_REQUIRED"] = "FETCH_REQUIRED";
    /**
     * The flag was not found or do not exist.
     */
    FSFlagStatus["NOT_FOUND"] = "NOT_FOUND";
    /**
     * The SDK is in PANIC mode: All features are disabled except for the one to fetch flags.
     */
    FSFlagStatus["PANIC"] = "PANIC";
})(FSFlagStatus || (FSFlagStatus = {}));

;// ./src/flag/forceVariation.ts

function forceVariation({ flagDTO, config, visitorVariationState }) {
    if (false) {}
    return undefined;
}

;// ./src/flag/FsFlags.ts




class FSFlag {
    _visitor;
    _key;
    _defaultValue;
    hasGetValueBeenCalled = false;
    constructor(param) {
        const { key, visitor } = param;
        this._key = key;
        this._visitor = visitor;
    }
    exists() {
        if (!this._visitor) {
            return false;
        }
        const flagDTO = this._visitor?.flagsData.get(this._key);
        const forcedFlagDTO = forceVariation({
            flagDTO,
            config: this._visitor.config,
            visitorVariationState: this._visitor.visitorVariationState
        });
        const flag = forcedFlagDTO || flagDTO;
        return !!(flag?.campaignId && flag?.variationId && flag?.variationGroupId);
    }
    get metadata() {
        if (!this._visitor) {
            return FSFlagMetadata.Empty();
        }
        const flagDTO = this._visitor.flagsData.get(this._key);
        const forcedFlagDTO = forceVariation({
            flagDTO,
            config: this._visitor.config,
            visitorVariationState: this._visitor.visitorVariationState
        });
        return this._visitor.getFlagMetadata({
            key: this._key,
            flag: forcedFlagDTO || flagDTO
        });
    }
    async visitorExposed() {
        if (!this._visitor) {
            return;
        }
        const flagDTO = this._visitor.flagsData.get(this._key);
        const forcedFlagDTO = forceVariation({
            flagDTO,
            config: this._visitor.config,
            visitorVariationState: this._visitor.visitorVariationState
        });
        return this._visitor.visitorExposed({
            key: this._key,
            flag: forcedFlagDTO || flagDTO,
            defaultValue: this._defaultValue,
            hasGetValueBeenCalled: this.hasGetValueBeenCalled
        });
    }
    getValue(defaultValue, visitorExposed = true) {
        this._defaultValue = defaultValue;
        this.hasGetValueBeenCalled = true;
        if (!this._visitor) {
            return defaultValue;
        }
        const flagDTO = this._visitor.flagsData.get(this._key);
        const forcedFlagDTO = forceVariation({
            flagDTO,
            config: this._visitor.config,
            visitorVariationState: this._visitor.visitorVariationState
        });
        const flag = forcedFlagDTO || flagDTO;
        this._visitor.sendExposedVariation(flag);
        return this._visitor.getFlagValue({
            key: this._key,
            defaultValue,
            flag,
            visitorExposed
        });
    }
    get status() {
        if (this._visitor?.flagsStatus?.status === FSFetchStatus.PANIC) {
            return FSFlagStatus.PANIC;
        }
        if (!this.exists()) {
            return FSFlagStatus.NOT_FOUND;
        }
        if (this._visitor?.flagsStatus?.status === FSFetchStatus.FETCH_REQUIRED || this._visitor?.flagsStatus?.status === FSFetchStatus.FETCHING) {
            return FSFlagStatus.FETCH_REQUIRED;
        }
        return FSFlagStatus.FETCHED;
    }
}

;// ./src/flag/FSFlagCollection.ts



/**
 * Represents a collection of flags.
 */
class FSFlagCollection {
    _visitor;
    _keys = new Set();
    _flags;
    /**
       * Creates a new instance of FSFlagCollection.
       * @param param - The parameter object.
       * @param param.visitor - The visitor delegate.
       * @param param.flags - The initial flags.
       */
    constructor(param) {
        const { visitor, flags } = param;
        this._visitor = visitor;
        this._flags = flags || new Map();
        if (this._flags.size === 0) {
            this._keys = new Set(visitor?.flagsData.keys());
            this._keys.forEach((key) => {
                this._flags.set(key, new FSFlag({
                    key,
                    visitor
                }));
            });
        }
        else {
            this._keys = new Set(this._flags.keys());
        }
    }
    /**
     * @inheritdoc
     */
    get size() {
        return this._keys.size;
    }
    /**
     * @inheritdoc
     */
    get(key) {
        const flag = this._flags.get(key);
        if (!flag) {
            if (this._visitor?.config) {
                logWarningSprintf(this._visitor.config, GET_FLAG, GET_FLAG_NOT_FOUND, this._visitor.visitorId, key);
            }
            return new FSFlag({ key });
        }
        return flag;
    }
    /**
     * @inheritdoc
     */
    has(key) {
        return this._keys.has(key);
    }
    /**
     * @inheritdoc
     */
    keys() {
        return this._keys;
    }
    /**
     * @inheritdoc
     */
    [Symbol.iterator]() {
        let index = 0;
        const keysArray = Array.from(this._keys);
        return {
            next: () => {
                if (index < keysArray.length) {
                    const key = keysArray[index++];
                    return {
                        value: [key, this._flags.get(key)],
                        done: false
                    };
                }
                else {
                    return {
                        value: null,
                        done: true
                    };
                }
            }
        };
    }
    /**
     * @inheritdoc
     */
    filter(predicate) {
        const flags = new Map();
        this._flags.forEach((flag, key) => {
            if (predicate(flag, key, this)) {
                flags.set(key, flag);
            }
        });
        return new FSFlagCollection({
            visitor: this._visitor,
            flags
        });
    }
    /**
     * @inheritdoc
     */
    async exposeAll() {
        await Promise.all(Array.from(this._flags.values(), (flag) => flag.visitorExposed()));
    }
    /**
     * @inheritdoc
     */
    getMetadata() {
        const metadata = new Map();
        this._flags.forEach((flag, key) => {
            metadata.set(key, flag.metadata);
        });
        return metadata;
    }
    /**
     * @inheritdoc
     */
    toJSON() {
        const serializedData = [];
        this._flags.forEach((flag, key) => {
            const metadata = flag.metadata;
            serializedData.push({
                key,
                campaignId: metadata.campaignId,
                campaignName: metadata.campaignName,
                variationGroupId: metadata.variationGroupId,
                variationGroupName: metadata.variationGroupName,
                variationId: metadata.variationId,
                variationName: metadata.variationName,
                isReference: metadata.isReference,
                campaignType: metadata.campaignType,
                slug: metadata.slug,
                hex: valueToHex({ v: flag.getValue(null, false) })
            });
        });
        return serializedData;
    }
    forEach(callbackfn) {
        this._flags.forEach((flag, key) => {
            callbackfn(flag, key, this);
        });
    }
}

;// ./src/visitor/VisitorDelegate.ts






class VisitorDelegate extends VisitorAbstract {
    updateContext(context, value) {
        this.getStrategy().updateContext(context, value);
        this.loadPredefinedContext();
    }
    clearContext() {
        this.getStrategy().clearContext();
    }
    getFlag(key) {
        if (this.flagsStatus.status !== FSFetchStatus.FETCHED
            && this.flagsStatus.status !== FSFetchStatus.FETCHING
            && this.flagsStatus.status !== FSFetchStatus.INITIAL_DATA) {
            logWarningSprintf(this.config, GET_FLAG, visitorFlagSyncStatusMessage(this.flagsStatus.reason), this.visitorId, key);
        }
        return new FSFlag({
            key,
            visitor: this
        });
    }
    getFlags() {
        return new FSFlagCollection({ visitor: this });
    }
    sendHit(hit) {
        return this.getStrategy().sendHit(hit);
    }
    sendHits(hits) {
        return this.getStrategy().sendHits(hits);
    }
    authenticate(visitorId) {
        this.getStrategy().authenticate(visitorId);
        this.updateCache();
    }
    unauthenticate() {
        this.getStrategy().unauthenticate();
        this.updateCache();
    }
    async fetchFlags() {
        await this.getStrategy().fetchFlags();
    }
    visitorExposed(param) {
        return this.getStrategy().visitorExposed(param);
    }
    getFlagValue(param) {
        return this.getStrategy().getFlagValue(param);
    }
    getFlagMetadata(param) {
        return this.getStrategy().getFlagMetadata(param);
    }
}

;// ./src/decision/BucketingManager.ts







class BucketingManager extends DecisionManager {
    _murmurHash;
    _sdkManager;
    get _bucketingContent() {
        return this._sdkManager.getBucketingContent();
    }
    constructor({ httpClient, config, murmurHash, sdkManager, trackingManager, flagshipInstanceId }) {
        super({
            httpClient,
            config,
            trackingManager,
            flagshipInstanceId
        });
        this._murmurHash = murmurHash;
        this._sdkManager = sdkManager;
    }
    async sendContext(visitor) {
        try {
            if (Object.keys(visitor.context).length <= 3 || !visitor.hasConsented || !visitor.hasContextBeenUpdated) {
                return;
            }
            visitor.hasContextBeenUpdated = false;
            const SegmentHit = new Segment({
                context: visitor.context,
                visitorId: visitor.visitorId,
                anonymousId: visitor.anonymousId
            });
            await visitor.sendHit(SegmentHit);
            const hitTroubleshooting = new Troubleshooting({
                label: TroubleshootingLabel.VISITOR_SEND_HIT,
                logLevel: LogLevel.INFO,
                traffic: visitor.traffic || 0,
                visitorId: visitor.visitorId,
                visitorSessionId: visitor.instanceId,
                flagshipInstanceId: visitor.sdkInitialData?.instanceId,
                anonymousId: visitor.anonymousId,
                config: this.config,
                hitContent: SegmentHit.toApiKeys()
            });
            visitor.segmentHitTroubleshooting = hitTroubleshooting;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logError(this.config, error.message || error, 'sendContext');
        }
    }
    async getThirdPartySegment(visitorId) {
        const url = sprintf(THIRD_PARTY_SEGMENT_URL, this.config.envId, visitorId);
        const now = Date.now();
        const contexts = {};
        try {
            const response = await this._httpClient.getAsync(url, { nextFetchConfig: this.config.nextFetchConfig });
            const content = response.body;
            if (Array.isArray(content)) {
                for (const item of content) {
                    contexts[`${item.partner}::${item.segment}`] = item.value;
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logError(this.config, errorFormat(error.message || error, {
                url,
                nextFetchConfig: this.config.nextFetchConfig,
                duration: Date.now() - now
            }), GET_THIRD_PARTY_SEGMENT);
        }
        return contexts;
    }
    async getCampaignsAsync(visitor) {
        if (!this._bucketingContent) {
            return null;
        }
        const troubleshooting = this._bucketingContent?.accountSettings?.troubleshooting;
        this.troubleshooting = undefined;
        if (troubleshooting) {
            this.troubleshooting = {
                startDate: new Date(troubleshooting.startDate),
                endDate: new Date(troubleshooting.endDate),
                timezone: troubleshooting.timezone,
                traffic: troubleshooting.traffic
            };
        }
        if (this._bucketingContent.panic) {
            this.panic = true;
            return [];
        }
        this.panic = false;
        if (!this._bucketingContent.campaigns) {
            return null;
        }
        if (this.config.fetchThirdPartyData) {
            const thirdPartySegments = await this.getThirdPartySegment(visitor.visitorId);
            visitor.updateContext(thirdPartySegments);
        }
        await this.sendContext(visitor);
        const visitorCampaigns = [];
        this._bucketingContent.campaigns.forEach(campaign => {
            const currentCampaigns = this.getVisitorCampaigns(campaign.variationGroups, campaign.id, campaign.type, visitor);
            if (currentCampaigns) {
                currentCampaigns.slug = campaign.slug ?? null;
                currentCampaigns.name = campaign.name;
                visitorCampaigns.push(currentCampaigns);
            }
        });
        return visitorCampaigns;
    }
    getVisitorCampaigns(variationGroups, campaignId, campaignType, visitor) {
        for (const variationGroup of variationGroups) {
            const check = this.isMatchTargeting(variationGroup, visitor);
            if (check) {
                const variation = this.getVariation(variationGroup, visitor);
                if (!variation) {
                    return null;
                }
                return {
                    id: campaignId,
                    variation,
                    variationGroupId: variationGroup.id,
                    variationGroupName: variationGroup.name,
                    type: campaignType
                };
            }
        }
        return null;
    }
    getVariation(variationGroup, visitor) {
        const hash = this._murmurHash.murmurHash3Int32(variationGroup.id + visitor.visitorId);
        const hashAllocation = hash % 100;
        let totalAllocation = 0;
        for (const variation of variationGroup.variations) {
            const assignmentsHistory = visitor.visitorCache?.data?.assignmentsHistory;
            const cacheVariationId = assignmentsHistory ? assignmentsHistory[variationGroup.id] : null;
            if (cacheVariationId) {
                const newVariation = variationGroup.variations.find(x => x.id === cacheVariationId);
                if (!newVariation) {
                    continue;
                }
                logDebugSprintf(this.config, ALLOCATION, BUCKETING_VARIATION_CACHE, visitor.visitorId, newVariation.id);
                return {
                    id: newVariation.id,
                    name: newVariation.name,
                    modifications: newVariation.modifications,
                    reference: newVariation.reference
                };
            }
            if (variation.allocation === undefined || variation.allocation === 0) {
                continue;
            }
            totalAllocation += variation.allocation;
            if (hashAllocation < totalAllocation) {
                logDebugSprintf(this.config, ALLOCATION, BUCKETING_NEW_ALLOCATION, visitor.visitorId, variation.id, totalAllocation);
                return {
                    id: variation.id,
                    modifications: variation.modifications,
                    reference: variation.reference,
                    name: variation.name
                };
            }
        }
        return null;
    }
    isMatchTargeting(variationGroup, visitor) {
        if (!variationGroup || !variationGroup.targeting || !variationGroup.targeting.targetingGroups) {
            return false;
        }
        return variationGroup.targeting.targetingGroups.some(targetingGroup => this.checkAndTargeting(targetingGroup.targetings, visitor));
    }
    isANDListOperator(operator) {
        return ['NOT_EQUALS', 'NOT_CONTAINS'].includes(operator);
    }
    checkAndTargeting(targetings, visitor) {
        let contextValue;
        let check = false;
        for (const { key, value, operator } of targetings) {
            if (operator === 'EXISTS') {
                if (key in visitor.context) {
                    check = true;
                    continue;
                }
                check = false;
                break;
            }
            if (operator === 'NOT_EXISTS') {
                if (key in visitor.context) {
                    check = false;
                    break;
                }
                check = true;
                continue;
            }
            if (key === 'fs_all_users') {
                check = true;
                continue;
            }
            if (key === 'fs_users') {
                contextValue = visitor.visitorId;
            }
            else {
                if (!(key in visitor.context)) {
                    check = false;
                    break;
                }
                contextValue = visitor.context[key];
            }
            check = this.testOperator(operator, contextValue, value);
            if (!check) {
                break;
            }
        }
        return check;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    testListOperatorLoop(operator, contextValue, value, initialCheck) {
        let check = initialCheck;
        for (const v of value) {
            check = this.testOperator(operator, contextValue, v);
            if (check !== initialCheck) {
                break;
            }
        }
        return check;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    testListOperator(operator, contextValue, value) {
        const andOperator = this.isANDListOperator(operator);
        if (andOperator) {
            return this.testListOperatorLoop(operator, contextValue, value, true);
        }
        return this.testListOperatorLoop(operator, contextValue, value, false);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    testOperator(operator, contextValue, value) {
        let check;
        if (Array.isArray(value)) {
            return this.testListOperator(operator, contextValue, value);
        }
        switch (operator) {
            case 'EQUALS':
                check = contextValue === value;
                break;
            case 'NOT_EQUALS':
                check = contextValue !== value;
                break;
            case 'CONTAINS':
                check = contextValue.toString().includes(value.toString());
                break;
            case 'NOT_CONTAINS':
                check = !contextValue.toString().includes(value.toString());
                break;
            case 'GREATER_THAN':
                check = contextValue > value;
                break;
            case 'LOWER_THAN':
                check = contextValue < value;
                break;
            case 'GREATER_THAN_OR_EQUALS':
                check = contextValue >= value;
                break;
            case 'LOWER_THAN_OR_EQUALS':
                check = contextValue <= value;
                break;
            case 'STARTS_WITH':
                check = contextValue.toString().startsWith(value.toString());
                break;
            case 'ENDS_WITH':
                check = contextValue.toString().endsWith(value.toString());
                break;
            default:
                check = false;
                break;
        }
        return check;
    }
}

;// ./src/utils/HttpError.ts
class HttpError extends Error {
    _statusCode;
    _headers;
    get headers() {
        return this._headers;
    }
    get statusCode() {
        return this._statusCode;
    }
    constructor(statusCode, message, headers) {
        super(message);
        this._statusCode = statusCode;
        this._headers = headers;
    }
}

;// ./src/LocalAbortController.ts
const LocalAbortController = AbortController;

;// ./src/depsNode.native.ts
const myFetch = (input, init) => fetch(input, init);



;// ./src/utils/HttpClient.ts



class HttpClient {
    async getResponse(response) {
        const applicationType = response.headers.get('Content-Type');
        const checkJson = applicationType?.includes('application/json');
        let body;
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        if (checkJson && response.ok && response.status !== 204) {
            body = await response.json();
        }
        if (response.status >= 400) {
            const bodyString = await response.text();
            throw new HttpError(response.status, bodyString || response.statusText, headers);
        }
        return {
            status: response.status,
            body,
            headers
        };
    }
    getAbortController() {
        const AbortCtrl = typeof globalThis.AbortController !== 'undefined'
            ? globalThis.AbortController
            : LocalAbortController;
        return new AbortCtrl;
    }
    async getAsync(url, options) {
        const c = this.getAbortController();
        const id = setTimeout(() => c.abort(), (options?.timeout ? options.timeout : REQUEST_TIME_OUT) * 1000);
        try {
            const response = await myFetch(url, {
                method: 'GET',
                headers: options?.headers,
                signal: c.signal,
                keepalive: true,
                next: options?.nextFetchConfig
            });
            return this.getResponse(response);
        }
        finally {
            clearTimeout(id);
        }
    }
    async postAsync(url, options) {
        const c = this.getAbortController();
        const id = setTimeout(() => c.abort(), options.timeout ? options.timeout * 1000 : REQUEST_TIME_OUT * 1000);
        try {
            const response = await myFetch(url, {
                method: 'POST',
                headers: options.headers,
                body: JSON.stringify(options.body),
                signal: c.signal,
                keepalive: true,
                next: options?.nextFetchConfig
            });
            return this.getResponse(response);
        }
        finally {
            clearTimeout(id);
        }
    }
}

;// ./src/decision/EdgeManager.ts

class EdgeManager extends BucketingManager {
    getCampaignsAsync(visitor) {
        return super.getCampaignsAsync(visitor);
    }
}

;// ./src/config/EdgeConfig.ts


class EdgeConfig extends FlagshipConfig {
    constructor(param) {
        super({
            ...param,
            decisionMode: DecisionMode.BUCKETING_EDGE
        });
    }
}

;// ./src/main/BucketingSdkManager.ts




class BucketingSdkManager {
    _httpClient;
    _config;
    _trackingManager;
    _intervalID;
    _lastModified;
    _isPooling;
    _EAIConfig;
    _bucketingContent;
    _lastBucketingTimestamp;
    _flagshipInstanceId;
    constructor({ httpClient, sdkConfig, trackingManager, flagshipInstanceId }) {
        this._httpClient = httpClient;
        this._config = sdkConfig;
        this._trackingManager = trackingManager;
        this._bucketingContent = sdkConfig.initialBucketing;
        this._flagshipInstanceId = flagshipInstanceId;
        this._lastModified = '';
    }
    resetSdk() {
        if (this._intervalID) {
            clearInterval(this._intervalID);
        }
        this._isPooling = false;
        this._intervalID = undefined;
        this._lastModified = '';
        this._bucketingContent = undefined;
        this._EAIConfig = undefined;
        logInfo(this._config, BUCKETING_POOLING_STOPPED, PROCESS_BUCKETING);
    }
    getBucketingContent() {
        return this._bucketingContent;
    }
    async initSdk() {
        const timeout = this._config.pollingInterval * 1000;
        await this.fetchBucketingFile();
        if (timeout === 0) {
            return;
        }
        logInfo(this._config, BUCKETING_POOLING_STARTED, PROCESS_BUCKETING);
        this._intervalID = setInterval(() => {
            this.fetchBucketingFile();
        }, timeout);
    }
    getEAIConfig() {
        return this._EAIConfig;
    }
    sendTroubleshooting(headers, url, response, now) {
        const troubleshootingHit = new Troubleshooting({
            visitorId: this._flagshipInstanceId,
            flagshipInstanceId: this._flagshipInstanceId,
            label: TroubleshootingLabel.SDK_BUCKETING_FILE,
            traffic: 0,
            logLevel: LogLevel.INFO,
            config: this._config,
            httpRequestHeaders: headers,
            httpRequestMethod: 'POST',
            httpRequestUrl: url,
            httpResponseBody: response?.body,
            httpResponseHeaders: response?.headers,
            httpResponseCode: response?.status,
            httpResponseTime: Date.now() - now
        });
        this._trackingManager.initTroubleshootingHit = troubleshootingHit;
    }
    sendErrorTroubleshooting(headers, url, error, now) {
        const troubleshootingHit = new Troubleshooting({
            visitorId: this._flagshipInstanceId,
            flagshipInstanceId: this._flagshipInstanceId,
            label: TroubleshootingLabel.SDK_BUCKETING_FILE_ERROR,
            traffic: 0,
            logLevel: LogLevel.INFO,
            config: this._config,
            httpRequestHeaders: headers,
            httpRequestMethod: 'POST',
            httpRequestUrl: url,
            httpResponseBody: error?.message,
            httpResponseHeaders: error?.headers,
            httpResponseCode: error?.statusCode,
            httpResponseTime: Date.now() - now
        });
        this._trackingManager.initTroubleshootingHit = troubleshootingHit;
    }
    handlePollingResponse(params) {
        const { response } = params;
        if (response.status === 200) {
            logDebugSprintf(this._config, PROCESS_BUCKETING, POLLING_EVENT_200, response.body);
            this._bucketingContent = response.body;
            this._lastBucketingTimestamp = new Date().toISOString();
            this._EAIConfig = {
                eaiCollectEnabled: !!this._bucketingContent?.accountSettings?.eaiActivationEnabled,
                eaiActivationEnabled: !!this._bucketingContent?.accountSettings?.eaiCollectEnabled
            };
            this.sendTroubleshooting(params.headers, params.url, response, params.now);
        }
        else if (response.status === 304) {
            logDebug(this._config, POLLING_EVENT_300, PROCESS_BUCKETING);
        }
        const lastModified = response?.headers?.['last-modified'];
        if (lastModified) {
            if (this._lastModified !== lastModified && this._config.onBucketingUpdated) {
                this._config.onBucketingUpdated(new Date(lastModified));
            }
            this._lastModified = lastModified;
        }
        this._isPooling = false;
    }
    async fetchBucketingFile() {
        if (this._isPooling) {
            return;
        }
        this._isPooling = true;
        const url = sprintf(BUCKETING_API_URL, this._config.envId);
        const headers = {
            [HEADER_X_SDK_CLIENT]: SDK_INFO.name,
            [HEADER_X_SDK_VERSION]: SDK_INFO.version,
            [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON
        };
        const now = Date.now();
        try {
            if (this._lastModified) {
                headers['if-modified-since'] = this._lastModified;
            }
            const response = await this._httpClient.getAsync(url, {
                headers,
                timeout: this._config.timeout,
                nextFetchConfig: this._config.nextFetchConfig
            });
            this.handlePollingResponse({
                response,
                headers,
                url,
                now
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            this._isPooling = false;
            logError(this._config, errorFormat(POLLING_EVENT_FAILED, {
                url,
                headers,
                error,
                nextFetchConfig: this._config.nextFetchConfig,
                method: 'GET',
                duration: Date.now() - now
            }), PROCESS_BUCKETING);
            this.sendErrorTroubleshooting(headers, url, error, now);
        }
    }
}

;// ./src/main/EdgeSdkManager.ts
class EdgeSdkManager {
    _httpClient;
    _config;
    _trackingManager;
    _bucketingContent;
    _flagshipInstanceId;
    constructor({ httpClient, sdkConfig, trackingManager, flagshipInstanceId }) {
        this._httpClient = httpClient;
        this._config = sdkConfig;
        this._trackingManager = trackingManager;
        this._bucketingContent = sdkConfig.initialBucketing;
        this._flagshipInstanceId = flagshipInstanceId;
    }
    resetSdk() {
        //
    }
    getBucketingContent() {
        return this._bucketingContent;
    }
    async initSdk() {
        //
    }
    getEAIConfig() {
        return undefined;
    }
}

;// ./src/main/ApiSdkManager.ts





class ApiSdkManager {
    _httpClient;
    _config;
    _trackingManager;
    _EAIConfig;
    _flagshipInstanceId;
    constructor({ httpClient, sdkConfig, trackingManager, flagshipInstanceId }) {
        this._httpClient = httpClient;
        this._config = sdkConfig;
        this._trackingManager = trackingManager;
        this._flagshipInstanceId = flagshipInstanceId;
    }
    resetSdk() {
        this._EAIConfig = undefined;
    }
    getBucketingContent() {
        return undefined;
    }
    sendTroubleshooting(accountSettings, url, response, now) {
        const troubleshooting = new Troubleshooting({
            flagshipInstanceId: this._flagshipInstanceId,
            label: TroubleshootingLabel.ACCOUNT_SETTINGS,
            logLevel: LogLevel.DEBUG,
            visitorId: this._flagshipInstanceId,
            config: this._config,
            accountSettings,
            traffic: 0,
            httpRequestMethod: 'POST',
            httpRequestUrl: url,
            httpResponseHeaders: response?.headers,
            httpResponseCode: response?.status,
            httpResponseTime: Date.now() - now
        });
        this._trackingManager.initTroubleshootingHit = troubleshooting;
    }
    sendErrorTroubleshooting(url, error, now) {
        const troubleshootingHit = new Troubleshooting({
            visitorId: this._flagshipInstanceId,
            flagshipInstanceId: this._flagshipInstanceId,
            label: TroubleshootingLabel.ACCOUNT_SETTINGS_ERROR,
            traffic: 0,
            logLevel: LogLevel.ERROR,
            config: this._config,
            httpRequestMethod: 'POST',
            httpRequestUrl: url,
            httpResponseBody: error?.message,
            httpResponseHeaders: error?.headers,
            httpResponseCode: error?.status,
            httpResponseTime: Date.now() - now
        });
        this._trackingManager.initTroubleshootingHit = troubleshootingHit;
    }
    async initSdk() {
        const now = Date.now();
        const url = sprintf(CDN_ACCOUNT_SETTINGS_URL, this._config.envId);
        try {
            const response = await this._httpClient.getAsync(url);
            this._EAIConfig = response.body.accountSettings;
            this.sendTroubleshooting(response.body.accountSettings, url, response, now);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this._config, 'Error while fetching EAI config: {0}', error?.message || error);
            this.sendErrorTroubleshooting(url, error, now);
        }
    }
    getEAIConfig() {
        return this._EAIConfig;
    }
}

;// ./src/emotionAI/CommonEmotionAI.ts






class CommonEmotionAI {
    _EAIScore;
    _EAIScoreChecked;
    _httpClient;
    _sdkConfig;
    _eAIConfig;
    _isEAIDataCollecting;
    _fetchEAIScorePromise;
    _startScoringTimestamp;
    _scoringIntervalId;
    _onEAICollectStatusChange;
    _visitor;
    /**
     * Indicates whether EAI data has been collected
     */
    _startCollectingEAIDataTimestamp;
    constructor({ httpClient, sdkConfig, eAIConfig }) {
        this._EAIScoreChecked = false;
        this._httpClient = httpClient;
        this._sdkConfig = sdkConfig;
        this._eAIConfig = eAIConfig;
        this._isEAIDataCollecting = false;
    }
    init(visitor) {
        this._visitor = visitor;
    }
    onEAICollectStatusChange(callback) {
        this._onEAICollectStatusChange = callback;
    }
    get EAIScore() {
        return this._EAIScore;
    }
    get EAIScoreChecked() {
        return this._EAIScoreChecked;
    }
    setIsEAIDataCollected(isCollected) {
        return this._visitor.setIsEAIDataCollected(isCollected);
    }
    isEAIDataCollected() {
        return this._visitor.isEAIDataCollected();
    }
    sendEAIScoreTroubleshooting(eAIScore, endpoint) {
        const troubleshooting = new Troubleshooting({
            flagshipInstanceId: this._visitor.sdkInitialData?.instanceId,
            visitorId: this._visitor.visitorId,
            label: TroubleshootingLabel.EMOTION_AI_SCORE_FROM_LOCAL_CACHE,
            logLevel: LogLevel.DEBUG,
            eAIScore,
            isEAIScoreFromLocalCache: true,
            config: this._sdkConfig,
            httpRequestUrl: endpoint,
            traffic: this._visitor.traffic
        });
        this._visitor.sendTroubleshooting(troubleshooting);
    }
    // eslint-disable-next-line max-params
    sendRequestTroubleshooting(response, label, endpoint, method = 'GET', apiKeys, eAIScore) {
        const troubleshooting = new Troubleshooting({
            flagshipInstanceId: this._visitor.sdkInitialData?.instanceId,
            visitorId: this._visitor.visitorId,
            label,
            logLevel: LogLevel.DEBUG,
            hitContent: apiKeys,
            eAIScore,
            httpResponseBody: response.body,
            httpRequestMethod: method,
            httpRequestUrl: endpoint,
            httpResponseCode: response.status,
            httpResponseHeaders: response.headers,
            traffic: this._visitor.traffic,
            config: this._sdkConfig
        });
        this._visitor.sendTroubleshooting(troubleshooting);
    }
    sendRequestTroubleshootingError(error, label, endpoint, apiKeys) {
        const troubleshooting = new Troubleshooting({
            flagshipInstanceId: this._visitor.sdkInitialData?.instanceId,
            visitorId: this._visitor.visitorId,
            label,
            logLevel: LogLevel.ERROR,
            httpRequestMethod: 'GET',
            httpRequestUrl: endpoint,
            hitContent: apiKeys,
            traffic: this._visitor.traffic,
            httpResponseBody: error?.message,
            httpResponseHeaders: error?.headers,
            httpResponseCode: error?.statusCode,
            config: this._sdkConfig
        });
        this._visitor.sendTroubleshooting(troubleshooting);
    }
    sendCollectingTroubleshooting(timestamp, label, score) {
        const troubleshooting = new Troubleshooting({
            flagshipInstanceId: this._visitor.sdkInitialData?.instanceId,
            visitorId: this._visitor.visitorId,
            label,
            logLevel: LogLevel.DEBUG,
            eAIDataTimestamp: new Date(timestamp).toISOString(),
            config: this._sdkConfig,
            eAIScore: score,
            traffic: this._visitor.traffic
        });
        this._visitor.sendTroubleshooting(troubleshooting);
    }
    sendCollectingUsageHit(label) {
        const usageHit = new UsageHit({
            visitorId: this._visitor.sdkInitialData?.instanceId,
            label,
            config: this._sdkConfig,
            logLevel: LogLevel.DEBUG
        });
        this._visitor.sendUsageHit(usageHit);
    }
    async fetchEAIScore(noCache = false) {
        if (!this._eAIConfig?.eaiActivationEnabled) {
            return undefined;
        }
        if (this._EAIScoreChecked) {
            return this._EAIScore;
        }
        const cachedEAIScore = await this._visitor.getCachedEAIScore();
        if (cachedEAIScore) {
            this._EAIScore = cachedEAIScore;
            this._EAIScoreChecked = true;
            this._visitor.context[EAI_SCORE_CONTEXT_KEY] = this._EAIScore?.eai?.eas;
            this.sendEAIScoreTroubleshooting(this._EAIScore);
            return this._EAIScore;
        }
        if (this._fetchEAIScorePromise) {
            await this._fetchEAIScorePromise;
            return this._EAIScore;
        }
        const visitorId = this._visitor.visitorId;
        const url = sprintf(EMOTION_AI_UC_URL, this._sdkConfig.envId, visitorId);
        const versionQuery = noCache ? `&v=${Date.now()}` : '';
        const endpoint = `${url}?partner=eai${versionQuery}`;
        try {
            this._fetchEAIScorePromise = this._httpClient.getAsync(endpoint);
            const response = await this._fetchEAIScorePromise;
            this._EAIScore = response.body;
            this._EAIScoreChecked = true;
            this.sendRequestTroubleshooting(response, TroubleshootingLabel.EMOTION_AI_SCORE, endpoint, 'GET', undefined, this._EAIScore);
            if (this._EAIScore) {
                this._visitor.setCachedEAIScore(this._EAIScore);
                this._visitor.updateContext(EAI_SCORE_CONTEXT_KEY, this._EAIScore?.eai?.eas);
            }
            logDebugSprintf(this._sdkConfig, FETCH_EAI_SCORE, FETCH_EAI_SCORE_SUCCESS, visitorId, this._EAIScore);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this._sdkConfig, FETCH_EAI_SCORE, FETCH_EAI_SCORE_ERROR, visitorId, error.message);
            this.sendRequestTroubleshootingError(error, TroubleshootingLabel.EMOTION_AI_SCORE_ERROR, endpoint);
        }
        finally {
            this._fetchEAIScorePromise = undefined;
        }
        return this._EAIScore;
    }
    async collectEAIEventsAsync(currentPage) {
        if (this._isEAIDataCollecting ||
            !this._eAIConfig?.eaiCollectEnabled) {
            return;
        }
        const isEAIDataCollected = await this.isEAIDataCollected();
        if (!this._eAIConfig.eaiActivationEnabled && isEAIDataCollected) {
            return;
        }
        const score = await this.fetchEAIScore();
        if (score) {
            return;
        }
        const visitorId = this._visitor.visitorId;
        await this.startCollectingEAIData(visitorId, currentPage);
    }
    async reportPageView(pageView) {
        if (!this._isEAIDataCollecting) {
            return;
        }
        return this.sendEAIEvent(pageView);
    }
    async sendEAIEvent(event) {
        const apiKeys = event.toApiKeys();
        try {
            const response = await this._httpClient.postAsync(EMOTION_AI_EVENT_URL, {
                body: apiKeys,
                headers: { [HEADER_CONTENT_TYPE]: HEADER_APPLICATION_JSON }
            });
            const label = apiKeys.t === 'PAGEVIEW' ? TroubleshootingLabel.EMOTION_AI_PAGE_VIEW : TroubleshootingLabel.EMOTION_AI_VISITOR_EVENT;
            this.sendRequestTroubleshooting(response, label, EMOTION_AI_EVENT_URL, 'POST', event.toApiKeys());
            logDebugSprintf(this._sdkConfig, SEND_EAI_EVENT, SEND_EAI_EVENT_SUCCESS, event.toApiKeys());
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            const label = apiKeys.t === 'PAGEVIEW' ? TroubleshootingLabel.EMOTION_AI_PAGE_VIEW_ERROR : TroubleshootingLabel.EMOTION_AI_VISITOR_EVENT_ERROR;
            this.sendRequestTroubleshootingError(error, label, EMOTION_AI_EVENT_URL, apiKeys);
            logErrorSprintf(this._sdkConfig, SEND_EAI_EVENT, SEND_EAI_EVENT_ERROR, error.message);
        }
    }
    finalizeDataCollection(isCollected) {
        if (this._scoringIntervalId) {
            clearInterval(this._scoringIntervalId);
            this._scoringIntervalId = undefined;
        }
        this._isEAIDataCollecting = false;
        this.setIsEAIDataCollected(isCollected);
    }
    stopCollectingEAIData() {
        this.sendCollectingTroubleshooting(Date.now(), TroubleshootingLabel.EMOTION_AI_STOP_COLLECTING);
        this.sendCollectingUsageHit(TroubleshootingLabel.EMOTION_AI_STOP_COLLECTING);
        this.removeListeners();
        if (!this._eAIConfig?.eaiActivationEnabled) {
            this._isEAIDataCollecting = false;
            this.setIsEAIDataCollected(true);
            return;
        }
        this._startScoringTimestamp = Date.now();
        this.sendCollectingTroubleshooting(this._startScoringTimestamp, TroubleshootingLabel.EMOTION_AI_START_SCORING);
        this._scoringIntervalId = setInterval(async () => {
            const elapsedTime = Date.now() - this._startScoringTimestamp;
            if (elapsedTime > MAX_SCORING_POLLING_TIME) {
                this.sendCollectingTroubleshooting(Date.now(), TroubleshootingLabel.EMOTION_AI_SCORING_FAILED);
                this.finalizeDataCollection(false);
                return;
            }
            this._EAIScoreChecked = false;
            const score = await this.fetchEAIScore(true);
            if (score) {
                this.sendCollectingTroubleshooting(Date.now(), TroubleshootingLabel.EMOTION_AI_SCORING_SUCCESS, score);
                this.finalizeDataCollection(true);
            }
        }, SCORING_INTERVAL);
    }
    async reportVisitorEvent(visitorEvent) {
        if (!this._isEAIDataCollecting) {
            return;
        }
        const timestampDiff = Date.now() - this._startCollectingEAIDataTimestamp;
        if (timestampDiff <= MAX_COLLECTING_TIME_MS) {
            this.sendEAIEvent(visitorEvent);
        }
        else if ((timestampDiff <= MAX_LAST_COLLECTING_TIME_MS)) {
            this.sendEAIEvent(visitorEvent);
            this.stopCollectingEAIData();
        }
        else {
            this.removeListeners();
            this._isEAIDataCollecting = false;
            this.setIsEAIDataCollected(false);
        }
    }
}

// EXTERNAL MODULE: ./src/emotionAI/hit/PageView.ts
var PageView = __webpack_require__(221);
;// ./src/emotionAI/EmotionAI.react-native.ts



class EmotionAI extends CommonEmotionAI {
    cleanup() {
        this._isEAIDataCollecting = false;
    }
    async processPageView(currentPage) {
        const pageView = new PageView.PageView(currentPage);
        await this.reportPageView(pageView);
    }
    async startCollectingEAIData(visitorId, currentPage) {
        this._isEAIDataCollecting = true;
        this._startCollectingEAIDataTimestamp = Date.now();
        this._onEAICollectStatusChange?.(true);
        if (currentPage) {
            await this.processPageView(currentPage);
        }
        this.sendCollectingTroubleshooting(this._startCollectingEAIDataTimestamp, TroubleshootingLabel.EMOTION_AI_STOP_COLLECTING);
        this.sendCollectingUsageHit(TroubleshootingLabel.EMOTION_AI_START_COLLECTING);
    }
    removeListeners() {
        this._onEAICollectStatusChange?.(false);
    }
}

;// ./src/visitor/VisitorProfileCache.react-native.ts


class VisitorProfileCache {
    _sdkConfig;
    constructor(sdkConfig) {
        this._sdkConfig = sdkConfig;
    }
    saveVisitorProfile(visitorProfile) {
        try {
            const extendedFlagship = Flagship;
            const onSaveVisitorProfile = extendedFlagship.getOnSaveVisitorProfile();
            onSaveVisitorProfile?.(JSON.stringify(visitorProfile));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this._sdkConfig, 'VisitorProfileCache.saveVisitorProfile', error?.message);
        }
    }
    loadVisitorProfile() {
        try {
            const extendedFlagship = Flagship;
            const data = extendedFlagship.getVisitorProfile();
            return data ? JSON.parse(data) : null;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logErrorSprintf(this._sdkConfig, 'VisitorProfileCache.loadVisitorProfile', error?.message);
        }
        return null;
    }
}

;// ./src/main/Flagship.ts


























/**
 * The `Flagship` class represents the SDK. It facilitates the initialization process and creation of new visitors.
 */
class Flagship {
    static _instance;
    _configManager;
    _config;
    _status;
    _visitorInstance;
    instanceId;
    lastInitializationTimestamp;
    _sdkManager;
    static visitorProfile;
    static onSaveVisitorProfile;
    _sdkApi;
    _visitorVariationState;
    set configManager(value) {
        this._configManager = value;
    }
    get configManager() {
        return this._configManager;
    }
    constructor() {
        this.instanceId = uuidV4();
        this._status = FSSdkStatus.SDK_NOT_INITIALIZED;
        const extendedFlagship = Flagship;
        extendedFlagship.setVisitorProfile = function (value) {
            Flagship.visitorProfile = value;
        };
        extendedFlagship.getVisitorProfile = function () {
            return Flagship.visitorProfile;
        };
        extendedFlagship.setOnSaveVisitorProfile = function (value) {
            Flagship.onSaveVisitorProfile = value;
        };
        extendedFlagship.getOnSaveVisitorProfile = function () {
            return Flagship.onSaveVisitorProfile;
        };
        this._visitorVariationState = {};
    }
    static getInstance() {
        if (false) {}
        else {
            if (!this._instance) {
                this._instance = new this();
            }
            return this._instance;
        }
    }
    setStatus(status) {
        if (this._status === status) {
            return;
        }
        this._status = status;
        VisitorAbstract.SdkStatus = status;
        const statusChanged = this.getConfig()?.onSdkStatusChanged;
        logInfoSprintf(this._config, PROCESS_SDK_STATUS, SDK_STATUS_CHANGED, FSSdkStatus[status]);
        if (this.getConfig().decisionMode !== DecisionMode.BUCKETING_EDGE) {
            if (status === FSSdkStatus.SDK_INITIALIZED) {
                this.configManager?.trackingManager?.startBatchingLoop();
            }
            if (status === FSSdkStatus.SDK_NOT_INITIALIZED) {
                this.configManager?.trackingManager?.stopBatchingLoop();
            }
        }
        if (statusChanged) {
            statusChanged(status);
        }
    }
    /**
     * Return current status of Flagship SDK.
     */
    static getStatus() {
        return this.getInstance()._status;
    }
    /**
     * Return current status of Flagship SDK.
     */
    getStatus() {
        return this._status;
    }
    /**
     * Return the current config set by the customer and used by the SDK.
     */
    static getConfig() {
        return this.getInstance()._config;
    }
    /**
     * Return the current config set by the customer and used by the SDK.
     */
    getConfig() {
        return this._config;
    }
    /**
     * Return the last visitor created if isNewInstance key is false. Return undefined otherwise.
     */
    getVisitor() {
        return this._visitorInstance;
    }
    /**
     * Return the last visitor created if isNewInstance key is false. Return undefined otherwise.
     */
    static getVisitor() {
        return this.getInstance().getVisitor();
    }
    buildConfig(config) {
        let newConfig;
        switch (config?.decisionMode) {
            case DecisionMode.BUCKETING:
                newConfig = new BucketingConfig(config);
                break;
            case DecisionMode.BUCKETING_EDGE:
                newConfig = new EdgeConfig(config);
                break;
            default:
                newConfig = new DecisionApiConfig(config);
                break;
        }
        return newConfig;
    }
    createManagers(httpClient, sdkConfig, trackingManager) {
        let sdkManager;
        switch (sdkConfig.decisionMode) {
            case DecisionMode.BUCKETING:
                sdkManager = new BucketingSdkManager({
                    httpClient,
                    sdkConfig,
                    trackingManager,
                    flagshipInstanceId: this.instanceId
                });
                return {
                    sdkManager,
                    decisionManager: new BucketingManager({
                        httpClient,
                        config: sdkConfig,
                        murmurHash: new MurmurHash(),
                        sdkManager,
                        trackingManager,
                        flagshipInstanceId: this.instanceId
                    })
                };
            case DecisionMode.BUCKETING_EDGE:
                sdkManager = new EdgeSdkManager({
                    httpClient,
                    sdkConfig,
                    trackingManager,
                    flagshipInstanceId: this.instanceId
                });
                return {
                    sdkManager,
                    decisionManager: new EdgeManager({
                        httpClient,
                        config: sdkConfig,
                        murmurHash: new MurmurHash(),
                        sdkManager,
                        trackingManager,
                        flagshipInstanceId: this.instanceId
                    })
                };
            default:
                sdkManager = new ApiSdkManager({
                    httpClient,
                    sdkConfig,
                    trackingManager,
                    flagshipInstanceId: this.instanceId
                });
                return {
                    sdkManager,
                    decisionManager: new ApiManager({
                        trackingManager,
                        httpClient,
                        config: sdkConfig,
                        flagshipInstanceId: this.instanceId
                    })
                };
        }
    }
    buildSdkApi(sharedActionTracking, sdkConfig) {
        if (false) {}
    }
    sendInitializedPostMessage() {
        if (false) {}
    }
    async initializeSdk(sdkConfig) {
        this.setStatus(FSSdkStatus.SDK_INITIALIZING);
        this._sdkManager?.resetSdk();
        let sharedActionTracking = this.configManager?.sharedActionTracking;
        if (false) {}
        const httpClient = new HttpClient();
        const trackingManager = this.configManager?.trackingManager || new TrackingManager(httpClient, sdkConfig, this.instanceId, sharedActionTracking);
        const { sdkManager, decisionManager } = this.createManagers(httpClient, sdkConfig, trackingManager);
        this._sdkManager = sdkManager;
        decisionManager.statusChangedCallback(this.setStatus.bind(this));
        decisionManager.flagshipInstanceId = this.instanceId;
        this.configManager = new ConfigManager(sdkConfig, decisionManager, trackingManager, sharedActionTracking);
        await this._sdkManager?.initSdk();
        this.setStatus(FSSdkStatus.SDK_INITIALIZED);
    }
    /**
     * Start the flagship SDK, with a custom configuration implementation
     * @param {string} envId : Environment id provided by Flagship.
     * @param {string} apiKey : Secure api key provided by Flagship.
     * @param {IFlagshipConfig} config : (optional) SDK configuration.
     */
    static async start(envId, apiKey, config) {
        const flagship = this.getInstance();
        const localConfig = flagship.buildConfig(config);
        localConfig.envId = envId;
        localConfig.apiKey = apiKey;
        flagship._config = localConfig;
        // check custom logger
        if (!localConfig.onLog && !localConfig.logManager) {
            localConfig.logManager = new FlagshipLogManager();
        }
        if (!envId || !apiKey) {
            flagship.setStatus(FSSdkStatus.SDK_NOT_INITIALIZED);
            logError(localConfig, INITIALIZATION_PARAM_ERROR, PROCESS_INITIALIZATION);
            return flagship;
        }
        logDebugSprintf(localConfig, PROCESS_INITIALIZATION, INITIALIZATION_STARTING, SDK_INFO.version, localConfig.decisionMode, localConfig);
        if (false) {}
        await flagship.initializeSdk(localConfig);
        logInfo(localConfig, sprintf(SDK_STARTED_INFO, SDK_INFO.version, FSSdkStatus[flagship._status], localConfig.decisionMode), PROCESS_INITIALIZATION);
        if (false) {}
        flagship.lastInitializationTimestamp = new Date().toISOString();
        flagship.sendInitializedPostMessage();
        return flagship;
    }
    /**
     * When called, it will batch and send all hits that are in the pool before the application is closed
     */
    async close() {
        await Flagship.close();
    }
    /**
     * When called, it will batch and send all hits that are in the pool before the application is closed
     */
    static async close() {
        await this._instance?.configManager?.trackingManager?.sendBatch();
    }
    /**
     * Creates a new Visitor instance.
     *
     * @param params - The parameters for creating the new Visitor.
     * @returns A new Visitor instance.
     */
    newVisitor(params) {
        return Flagship.newVisitor(params);
    }
    initializeConfigManager() {
        const config = new DecisionApiConfig();
        config.logManager = new FlagshipLogManager();
        const httpClient = new HttpClient();
        const trackingManager = new TrackingManager(httpClient, config);
        const decisionManager = new ApiManager({
            httpClient,
            config,
            trackingManager
        });
        this._config = config;
        this.configManager = new ConfigManager(config, decisionManager, trackingManager);
    }
    /**
     * Creates a new Visitor instance.
     *
     * @param params - The parameters for creating the new Visitor.
     * @returns A new Visitor instance.
     */
    static newVisitor({ visitorId, context, isAuthenticated, hasConsented, initialCampaigns, initialFlagsData, shouldSaveInstance, onFlagsStatusChanged }) {
        const saveInstance = shouldSaveInstance ?? isBrowser();
        const flagship = this.getInstance();
        if (!flagship.configManager) {
            flagship.initializeConfigManager();
            logError(flagship.getConfig(), NEW_VISITOR_NOT_READY, PROCESS_NEW_VISITOR);
        }
        const sdkConfig = flagship.getConfig();
        const configManager = flagship.configManager;
        if (hasConsented === undefined) {
            logWarning(sdkConfig, CONSENT_NOT_SPECIFY_WARNING, PROCESS_NEW_VISITOR);
        }
        const emotionAi = new EmotionAI({
            sdkConfig,
            httpClient: new HttpClient(),
            eAIConfig: flagship._sdkManager?.getEAIConfig()
        });
        const visitorProfileCache = new VisitorProfileCache(sdkConfig);
        VisitorAbstract.SdkStatus = flagship.getStatus();
        const visitorDelegate = new VisitorDelegate({
            visitorId,
            context: context || {},
            isAuthenticated: isAuthenticated ?? false,
            hasConsented: hasConsented ?? false,
            configManager,
            initialCampaigns,
            initialFlagsData,
            onFlagsStatusChanged,
            emotionAi,
            visitorProfileCache,
            monitoringData: {
                instanceId: this.getInstance().instanceId,
                lastInitializationTimestamp: this.getInstance().lastInitializationTimestamp,
                initialCampaigns,
                initialFlagsData
            },
            murmurHash: new MurmurHash(),
            visitorVariationState: flagship._visitorVariationState
        });
        if (false) {}
        const visitor = new Visitor(visitorDelegate);
        this.getInstance()._visitorInstance = saveInstance ? visitor : undefined;
        if (saveInstance) {
            logDebugSprintf(sdkConfig, PROCESS_NEW_VISITOR, SAVE_VISITOR_INSTANCE, visitor.visitorId);
        }
        if (sdkConfig.fetchNow && sdkConfig.decisionMode !== DecisionMode.BUCKETING_EDGE) {
            visitor.fetchFlags();
        }
        return visitor;
    }
}

;// ./src/flag/index.ts






;// ./src/index.ts









/* harmony default export */ const src = (Flagship);

var __webpack_exports__ABTastyWebSDKPostMessageType = __webpack_exports__.ABTastyWebSDKPostMessageType;
var __webpack_exports__APP_VERSION_CODE = __webpack_exports__.APP_VERSION_CODE;
var __webpack_exports__APP_VERSION_NAME = __webpack_exports__.APP_VERSION_NAME;
var __webpack_exports__CARRIER_NAME = __webpack_exports__.CARRIER_NAME;
var __webpack_exports__CacheStrategy = __webpack_exports__.CacheStrategy;
var __webpack_exports__DEVICE_LOCALE = __webpack_exports__.DEVICE_LOCALE;
var __webpack_exports__DEVICE_MODEL = __webpack_exports__.DEVICE_MODEL;
var __webpack_exports__DEVICE_TYPE = __webpack_exports__.DEVICE_TYPE;
var __webpack_exports__DecisionApiConfig = __webpack_exports__.DecisionApiConfig;
var __webpack_exports__DecisionMode = __webpack_exports__.DecisionMode;
var __webpack_exports__EventCategory = __webpack_exports__.EventCategory;
var __webpack_exports__FLAGSHIP_CLIENT = __webpack_exports__.FLAGSHIP_CLIENT;
var __webpack_exports__FLAGSHIP_CONTEXT = __webpack_exports__.FLAGSHIP_CONTEXT;
var __webpack_exports__FLAGSHIP_VERSION = __webpack_exports__.FLAGSHIP_VERSION;
var __webpack_exports__FLAGSHIP_VISITOR = __webpack_exports__.FLAGSHIP_VISITOR;
var __webpack_exports__FSFetchReasons = __webpack_exports__.FSFetchReasons;
var __webpack_exports__FSFetchStatus = __webpack_exports__.FSFetchStatus;
var __webpack_exports__FSFlag = __webpack_exports__.FSFlag;
var __webpack_exports__FSFlagCollection = __webpack_exports__.FSFlagCollection;
var __webpack_exports__FSFlagMetadata = __webpack_exports__.FSFlagMetadata;
var __webpack_exports__FSFlagStatus = __webpack_exports__.FSFlagStatus;
var __webpack_exports__FSSdkStatus = __webpack_exports__.FSSdkStatus;
var __webpack_exports__Flagship = __webpack_exports__.Flagship;
var __webpack_exports__HitType = __webpack_exports__.HitType;
var __webpack_exports__INTERFACE_NAME = __webpack_exports__.INTERFACE_NAME;
var __webpack_exports__INTERNET_CONNECTION = __webpack_exports__.INTERNET_CONNECTION;
var __webpack_exports__IP = __webpack_exports__.IP;
var __webpack_exports__LOCATION_CITY = __webpack_exports__.LOCATION_CITY;
var __webpack_exports__LOCATION_COUNTRY = __webpack_exports__.LOCATION_COUNTRY;
var __webpack_exports__LOCATION_LAT = __webpack_exports__.LOCATION_LAT;
var __webpack_exports__LOCATION_LONG = __webpack_exports__.LOCATION_LONG;
var __webpack_exports__LOCATION_REGION = __webpack_exports__.LOCATION_REGION;
var __webpack_exports__LogLevel = __webpack_exports__.LogLevel;
var __webpack_exports__OS_NAME = __webpack_exports__.OS_NAME;
var __webpack_exports__OS_VERSION_CODE = __webpack_exports__.OS_VERSION_CODE;
var __webpack_exports__OS_VERSION_NAME = __webpack_exports__.OS_VERSION_NAME;
var __webpack_exports__TroubleshootingLabel = __webpack_exports__.TroubleshootingLabel;
var __webpack_exports__Visitor = __webpack_exports__.Visitor;
var __webpack_exports__VisitorCacheStatus = __webpack_exports__.VisitorCacheStatus;
var __webpack_exports__default = __webpack_exports__["default"];
export { __webpack_exports__ABTastyWebSDKPostMessageType as ABTastyWebSDKPostMessageType, __webpack_exports__APP_VERSION_CODE as APP_VERSION_CODE, __webpack_exports__APP_VERSION_NAME as APP_VERSION_NAME, __webpack_exports__CARRIER_NAME as CARRIER_NAME, __webpack_exports__CacheStrategy as CacheStrategy, __webpack_exports__DEVICE_LOCALE as DEVICE_LOCALE, __webpack_exports__DEVICE_MODEL as DEVICE_MODEL, __webpack_exports__DEVICE_TYPE as DEVICE_TYPE, __webpack_exports__DecisionApiConfig as DecisionApiConfig, __webpack_exports__DecisionMode as DecisionMode, __webpack_exports__EventCategory as EventCategory, __webpack_exports__FLAGSHIP_CLIENT as FLAGSHIP_CLIENT, __webpack_exports__FLAGSHIP_CONTEXT as FLAGSHIP_CONTEXT, __webpack_exports__FLAGSHIP_VERSION as FLAGSHIP_VERSION, __webpack_exports__FLAGSHIP_VISITOR as FLAGSHIP_VISITOR, __webpack_exports__FSFetchReasons as FSFetchReasons, __webpack_exports__FSFetchStatus as FSFetchStatus, __webpack_exports__FSFlag as FSFlag, __webpack_exports__FSFlagCollection as FSFlagCollection, __webpack_exports__FSFlagMetadata as FSFlagMetadata, __webpack_exports__FSFlagStatus as FSFlagStatus, __webpack_exports__FSSdkStatus as FSSdkStatus, __webpack_exports__Flagship as Flagship, __webpack_exports__HitType as HitType, __webpack_exports__INTERFACE_NAME as INTERFACE_NAME, __webpack_exports__INTERNET_CONNECTION as INTERNET_CONNECTION, __webpack_exports__IP as IP, __webpack_exports__LOCATION_CITY as LOCATION_CITY, __webpack_exports__LOCATION_COUNTRY as LOCATION_COUNTRY, __webpack_exports__LOCATION_LAT as LOCATION_LAT, __webpack_exports__LOCATION_LONG as LOCATION_LONG, __webpack_exports__LOCATION_REGION as LOCATION_REGION, __webpack_exports__LogLevel as LogLevel, __webpack_exports__OS_NAME as OS_NAME, __webpack_exports__OS_VERSION_CODE as OS_VERSION_CODE, __webpack_exports__OS_VERSION_NAME as OS_VERSION_NAME, __webpack_exports__TroubleshootingLabel as TroubleshootingLabel, __webpack_exports__Visitor as Visitor, __webpack_exports__VisitorCacheStatus as VisitorCacheStatus, __webpack_exports__default as default };

//# sourceMappingURL=index.react-native.esm.js.map